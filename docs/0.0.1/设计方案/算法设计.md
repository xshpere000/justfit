# JustFit 算法设计文档

## 0. 文档信息

| 项目 | 内容 |
|------|------|
| 文档名称 | 算法设计文档 |
| 版本 | v1.0 |
| 日期 | 2026-02-07 |
| 项目版本 | v0.0.1 Beta |

## 1. 算法概述

### 1.1 算法分类

| 算法类型 | 分析对象 | 输出 |
|----------|----------|------|
| 僵尸 VM 检测 | 虚拟机 | 僵尸 VM 列表 + 证据 + 置信度 |
| Right Size | 虚拟机 | 配置建议 + 节省估算 + 风险评估 |
| 潮汐检测 | 虚拟机 | 周期模式 + 启停建议 + 节省估算 |
| 健康评分 | 集群/主机 | 健康分数 + 风险项 + 改善建议 |

### 1.2 算法依赖

```
指标数据 → 预处理 → 特征计算 → 算法判定 → 结果输出
            ↓
         数据验证
            ↓
         异常处理
```

## 2. 僵尸 VM 检测算法

### 2.1 算法原理

**定义：** 僵尸 VM 指在较长时间内持续低负载或无业务活动的虚拟机。

**检测维度：**
- CPU 使用率
- 内存使用率
- 磁盘 IO 活动
- 网络活动

### 2.2 算法流程

```
┌────────────────────────────────────────────────────────┐
│                    僵尸 VM 检测流程                     │
├────────────────────────────────────────────────────────┤
│                                                        │
│  1. 获取时间窗口内的指标数据                             │
│     │                                                  │
│     └─ 默认窗口: 14 天                                  │
│                                                         │
│  2. 计算统计特征                                        │
│     │                                                  │
│     ├─ CPU: 均值, P95, 峰值                            │
│     ├─ 内存: 均值, P95, 峰值                           │
│     ├─ 磁盘 IO: IOPS 均值, 吞吐量                       │
│     └─ 网络: 入站/出站流量均值                          │
│                                                         │
│  3. 应用判定规则                                        │
│     │                                                  │
│     └─ 所有维度都低于阈值 → 判定为僵尸                 │
│                                                         │
│  4. 计算置信度                                          │
│     │                                                  │
│     └─ 基于持续时间和指标水平计算                       │
│                                                         │
│  5. 生成建议                                            │
│     │                                                  │
│     ├─ 高置信度 → 建议关机                              │
│     └─ 中低置信度 → 建议进一步确认                       │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 2.3 判定规则

```go
// 僵尸 VM 判定规则
type ZombieRule struct {
    DurationDays int     // 检测窗口天数
    CPUMax       float64 // CPU 使用率上限 %
    MemMax       float64 // 内存使用率上限 %
    IOMax        float64 // IOPS 上限
    NetMax       float64 // 网络流量上限 MB/s
}

// 默认规则
var DefaultZombieRule = ZombieRule{
    DurationDays: 14,
    CPUMax:       5.0,
    MemMax:       10.0,
    IOMax:        10.0,
    NetMax:       0.1,
}

// 判定函数
func (a *ZombieAnalyzer) IsZombie(vm *VM, metrics *MetricStats) *ZombieResult {
    // 检查电源状态
    if vm.PowerState != "poweredOn" {
        return nil // 关机的 VM 不分析
    }

    // 检查是否为模板
    if vm.IsTemplate {
        return nil // 模板不分析
    }

    // 判定各维度
    cpuOK := metrics.CPU.Mean <= a.rule.CPUMax
    memOK := metrics.Memory.Mean <= a.rule.MemMax
    ioOK := metrics.DiskIO.IOPSMean <= a.rule.IOMax
    netOK := metrics.Network.MeanThroughputMB <= a.rule.NetMax

    // 所有维度都满足
    if cpuOK && memOK && ioOK && netOK {
        return &ZombieResult{
            IsZombie:    true,
            Confidence:  a.calculateConfidence(metrics),
            Reason:      a.buildReason(metrics),
            Suggestion:  a.getSuggestion(metrics),
        }
    }

    return nil
}

// 计算置信度
func (a *ZombieAnalyzer) calculateConfidence(metrics *MetricStats) float64 {
    // 基于指标水平计算置信度
    cpuScore := 1 - (metrics.CPU.Mean / a.rule.CPUMax)
    memScore := 1 - (metrics.Memory.Mean / a.rule.MemMax)
    ioScore := 1 - (metrics.DiskIO.IOPSMean / a.rule.IOMax)

    // 加权平均
    confidence := (cpuScore*0.4 + memScore*0.3 + ioScore*0.3)

    // 考虑持续时间
    durationFactor := min(metrics.DurationDays/14.0, 1.0)
    confidence *= (0.5 + 0.5*durationFactor)

    return min(confidence, 1.0)
}
```

### 2.4 输出结构

```json
{
  "entity_type": "vm",
  "entity_id": "vm-123",
  "entity_name": "test-server-01",
  "analysis_type": "zombie",
  "conclusion": "检测为僵尸虚拟机",
  "confidence": 0.85,
  "recommendation": "建议关机或迁移至低配主机",
  "risk_level": "medium",
  "evidence": {
    "duration_days": 14,
    "detection_window": {
      "start": "2026-01-24T00:00:00Z",
      "end": "2026-02-07T00:00:00Z"
    },
    "cpu": {
      "mean": 2.5,
      "p95": 4.2,
      "max": 8.1,
      "unit": "%"
    },
    "memory": {
      "mean": 8.3,
      "p95": 12.7,
      "max": 18.4,
      "unit": "%"
    },
    "disk_io": {
      "iops_mean": 3.2,
      "iops_max": 15.0,
      "throughput_mean_mb": 0.05
    },
    "network": {
      "in_mb_mean": 0.008,
      "out_mb_mean": 0.005
    },
    "thresholds": {
      "cpu_max": 5.0,
      "mem_max": 10.0,
      "io_max": 10.0
    }
  }
}
```

## 3. Right Size 评估算法

### 3.1 算法原理

**目标：** 根据历史使用情况，推荐合理的资源配置，提高资源利用率。

**关键概念：**
- 使用百分位 (P95) 而非峰值，避免偶发尖峰影响
- 预留缓冲空间 (通常 20-30%)
- 考虑超配比例

### 3.2 算法流程

```
┌─────────────────────────────────────────────────────────┐
│                  Right Size 评估流程                     │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  1. 获取历史指标数据                                     │
│     │                                                  │
│     └─ 默认窗口: 30 天                                  │
│                                                         │
│  2. 计算使用率统计                                      │
│     │                                                  │
│     ├─ CPU 使用率: P95, 均值, 峰值                      │
│     └─ 内存使用率: P95, 均值, 峰值                       │
│                                                         │
│  3. 计算推荐配置                                        │
│     │                                                  │
│     ├─ 推荐 vCPU = 当前 vCPU × P95 × (1 + buffer)      │
│     └─ 推荐内存 = 当前内存 × P95 × (1 + buffer)         │
│                                                         │
│  4. 判断调整方向                                        │
│     │                                                  │
│     ├─ P95 < 50% → 建议缩容                            │
│     ├─ P95 > 80% → 建议扩容                            │
│     └─ 50% ≤ P95 ≤ 80% → 配置合理                      │
│                                                         │
│  5. 评估风险                                            │
│     │                                                  │
│     └─ 基于波动性、峰值、趋势判断风险                   │
│                                                         │
│  6. 计算节省估算                                        │
│     │                                                  │
│     └─ (当前配置 - 推荐配置) / 当前配置                 │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 3.3 计算公式

```go
// Right Size 计算
type RightSizeCalculator struct {
    Percentile    float64 // 分析百分位 (默认 95)
    BufferRatio   float64 // 缓冲比例 (默认 0.2)
    MinVCPU       int     // 最小 vCPU
    MinMemory     int     // 最小内存 (MB)
    MaxOversub    float64 // 最大超配比例
}

func (c *RightSizeCalculator) Calculate(vm *VM, metrics []Metric) *RightSizeResult {
    // 1. 提取使用率数据
    cpuUsages := extractCPUUsage(metrics)
    memUsages := extractMemUsage(metrics)

    // 2. 计算百分位
    cpuP95 := percentile(cpuUsages, c.Percentile)
    memP95 := percentile(memUsages, c.Percentile)

    // 3. 计算推荐配置 (留 20% buffer)
    recommendedVCPU := int(math.Ceil(float64(vm.VCPU) * cpuP95 / 100 * (1 + c.BufferRatio)))
    recommendedMem := int(math.Ceil(float64(vm.VMem) * memP95 / 100 * (1 + c.BufferRatio)))

    // 4. 确保最小值
    if recommendedVCPU < c.MinVCPU {
        recommendedVCPU = c.MinVCPU
    }
    if recommendedMem < c.MinMemory {
        recommendedMem = c.MinMemory
    }

    // 5. 判断调整类型
    adjustment := c.classifyAdjustment(vm, recommendedVCPU, recommendedMem)

    // 6. 计算节省
    savings := c.calculateSavings(vm, recommendedVCPU, recommendedMem)

    return &RightSizeResult{
        Current: ResourceConfig{
            VCPU: vm.VCPU,
            Mem:  vm.VMem,
        },
        Recommended: ResourceConfig{
            VCPU: recommendedVCPU,
            Mem:  recommendedMem,
        },
        Utilization: UtilizationStats{
            CPUP95: cpuP95,
            CPUMax: max(cpuUsages),
            MemP95: memP95,
            MemMax: max(memUsages),
        },
        Adjustment:  adjustment,
        Savings:     savings,
        RiskLevel:   c.assessRisk(cpuUsages, memUsages),
    }
}

// 调整类型分类
func (c *RightSizeCalculator) classifyAdjustment(
    vm *VM,
    recVCPU, recMem int,
) AdjustmentType {
    cpuChange := float64(recVCPU-vm.VCPU) / float64(vm.VCPU)
    memChange := float64(recMem-vm.VMem) / float64(vm.VMem)

    if cpuChange < -0.3 && memChange < -0.3 {
        return AdjustmentDownsizeLarge // 大幅缩容
    } else if cpuChange < -0.1 || memChange < -0.1 {
        return AdjustmentDownsizeSmall // 小幅缩容
    } else if cpuChange > 0.3 || memChange > 0.3 {
        return AdjustmentUpsize // 扩容
    } else {
        return AdjustmentNone // 合理
    }
}

// 风险评估
func (c *RightSizeCalculator) assessRisk(
    cpuUsages, memUsages []float64,
) RiskLevel {
    // 计算变异系数 (标准差/均值)
    cpuCV := coefficientOfVariation(cpuUsages)
    memCV := coefficientOfVariation(memUsages)

    // 波动性高 → 风险高
    if cpuCV > 0.5 || memCV > 0.5 {
        return RiskHigh
    } else if cpuCV > 0.3 || memCV > 0.3 {
        return RiskMedium
    }

    // 检查是否有接近 100% 的情况
    if max(cpuUsages) > 95 || max(memUsages) > 95 {
        return RiskHigh
    }

    return RiskLow
}
```

### 3.4 输出结构

```json
{
  "entity_type": "vm",
  "entity_id": "vm-456",
  "entity_name": "app-server-02",
  "analysis_type": "rightsize",
  "conclusion": "资源配置过高，建议缩容",
  "confidence": 0.9,
  "risk_level": "low",
  "recommendation": "建议将 vCPU 从 8 核降至 4 核，内存从 16GB 降至 8GB",
  "evidence": {
    "analysis_period_days": 30,
    "percentile": 95,
    "current_config": {
      "vcpu": 8,
      "mem_mb": 16384
    },
    "recommended_config": {
      "vcpu": 4,
      "mem_mb": 8192
    },
    "utilization": {
      "cpu": {
        "p95": 38.5,
        "max": 72.3,
        "mean": 25.2,
        "unit": "%"
      },
      "memory": {
        "p95": 42.8,
        "max": 68.5,
        "mean": 30.1,
        "unit": "%"
      }
    },
    "adjustment": "downsize_large",
    "savings": {
      "vcpu": 4,
      "mem_mb": 8192,
      "percentage": 50
    },
    "risk_assessment": {
      "level": "low",
      "buffer": 20,
      "notes": "使用率波动稳定，P95 值远低于当前配置",
      "rollback": "如遇性能问题，建议恢复原配置或增加至 6 vCPU / 12GB"
    }
  }
}
```

## 4. 潮汐检测算法

### 4.1 算法原理

**目标：** 识别具有周期性峰谷波动的工作负载，推荐合理的启停策略。

**检测方法：**
- 日周期检测：按小时聚合，识别日内规律
- 周周期检测：按星期聚合，识别周内规律
- 稳定性评分：评估周期规律的稳定性

### 4.2 算法流程

```
┌─────────────────────────────────────────────────────────┐
│                    潮汐检测流程                           │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  1. 获取历史指标数据                                     │
│     │                                                  │
│     └─ 默认窗口: 30 天 (至少 2 个完整周)                │
│                                                         │
│  2. 按时间维度聚合                                       │
│     │                                                  │
│     ├─ 日周期: 按小时聚合 (0-23)                        │
│     └─ 周周期: 按星期聚合 (周一-周日)                    │
│                                                         │
│  3. 检测周期模式                                        │
│     │                                                  │
│     ├─ 计算峰谷差                                      │
│     ├─ 识别峰值时段                                    │
│     └─ 识别谷值时段                                    │
│                                                         │
│  4. 计算稳定性评分                                      │
│     │                                                  │
│     └─ 使用方差分析评估模式稳定性                       │
│                                                         │
│  5. 生成启停建议                                        │
│     │                                                  │
│     ├─ 谷值时段建议关机                                │
│     ├─ 峰值前提前启动                                  │
│     └─ 计算节省估算                                    │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 4.3 检测算法

```go
// 潮汐检测
type TidalDetector struct {
    MinPeakDiff      float64 // 最小峰谷差 % (默认 40%)
    MinStabilityScore float64 // 最小稳定性评分 (默认 0.7)
    MinDataDays      int     // 最少数据天数 (默认 14)
}

func (d *TidalDetector) Detect(vm *VM, metrics []Metric) *TidalResult {
    if len(metrics) < d.MinDataDays*24 {
        return nil // 数据不足
    }

    // 1. 尝试日周期检测
    dailyPattern := d.detectDailyPattern(metrics)

    // 2. 尝试周周期检测
    weeklyPattern := d.detectWeeklyPattern(metrics)

    // 3. 选择最佳模式
    bestPattern := d.selectBestPattern(dailyPattern, weeklyPattern)

    if bestPattern == nil {
        return nil
    }

    // 4. 生成启停建议
    schedule := d.generateSchedule(bestPattern)

    // 5. 计算节省
    savings := d.estimateSavings(vm, bestPattern, schedule)

    return &TidalResult{
        CycleType:   bestPattern.Type,
        Stability:   bestPattern.Stability,
        PeakHours:   bestPattern.PeakHours,
        OffPeakHours: bestPattern.OffPeakHours,
        PeakDiff:    bestPattern.PeakDiff,
        Schedule:    schedule,
        Savings:     savings,
    }
}

// 日周期检测
func (d *TidalDetector) detectDailyPattern(metrics []Metric) *TidalPattern {
    // 按小时聚合
    hourlyData := make(map[int][]float64) // hour -> values

    for _, m := range metrics {
        hour := time.Unix(m.Timestamp, 0).Hour()
        hourlyData[hour] = append(hourlyData[hour], m.Value)
    }

    // 计算每小时平均值
    hourlyAvg := make([]float64, 24)
    for hour := 0; hour < 24; hour++ {
        values := hourlyData[hour]
        if len(values) > 0 {
            hourlyAvg[hour] = mean(values)
        }
    }

    // 计算峰谷差
    maxVal := max(hourlyAvg)
    minVal := min(hourlyAvg)
    peakDiff := (maxVal - minVal) / maxVal

    if peakDiff < d.MinPeakDiff/100 {
        return nil // 峰谷差不够
    }

    // 识别峰谷时段
    threshold := (maxVal + minVal) / 2
    peakHours := make([]int, 0)
    offPeakHours := make([]int, 0)

    for hour, val := range hourlyAvg {
        if val > threshold {
            peakHours = append(peakHours, hour)
        } else {
            offPeakHours = append(offPeakHours, hour)
        }
    }

    // 计算稳定性 (使用方差分析)
    stability := d.calculateStability(hourlyData)

    return &TidalPattern{
        Type:        CycleDaily,
        HourlyAvg:   hourlyAvg,
        PeakHours:   peakHours,
        OffPeakHours: offPeakHours,
        PeakDiff:    peakDiff * 100,
        Stability:   stability,
    }
}

// 生成启停计划
func (d *TidalDetector) generateSchedule(pattern *TidalPattern) *TidalSchedule {
    if pattern.Type == CycleDaily {
        // 找到连续的关机时段
        offPeakRanges := findConsecutiveRanges(pattern.OffPeakHours)

        // 选择最长的连续关机时段
        longestRange := maxBy(offPeakRanges, func(r []int) int { return len(r) })

        return &TidalSchedule{
            StopTime:  fmt.Sprintf("%02d:00", longestRange[0]),
            StartTime: fmt.Sprintf("%02d:00", (longestRange[len(longestRange)-1]+1)%24),
            Timezone:  "Asia/Shanghai",
        }
    }

    return nil
}
```

### 4.4 输出结构

```json
{
  "entity_type": "vm",
  "entity_id": "vm-789",
  "entity_name": "report-server",
  "analysis_type": "tidal",
  "conclusion": "检测到日周期性负载模式",
  "confidence": 0.82,
  "risk_level": "medium",
  "recommendation": "建议在 20:00-08:00 期间关机，可节省约 50% 能源",
  "evidence": {
    "analysis_period_days": 30,
    "cycle_type": "daily",
    "stability_score": 0.85,
    "peak_hours": [9, 10, 11, 14, 15, 16, 17],
    "off_peak_hours": [0, 1, 2, 3, 4, 5, 6, 19, 20, 21, 22, 23],
    "peak_difference": {
      "cpu": 72.5,
      "memory": 58.3,
      "unit": "percentage points"
    },
    "hourly_pattern": {
      "0": 2.1, "1": 1.8, "2": 1.5, "3": 1.2, "4": 1.0,
      "5": 1.5, "6": 3.2, "7": 15.8, "8": 45.2, "9": 68.5,
      "10": 72.3, "11": 65.8, "12": 45.2, "13": 52.1, "14": 68.9,
      "15": 71.2, "16": 65.4, "17": 48.5, "18": 25.3, "19": 12.8,
      "20": 5.2, "21": 3.1, "22": 2.5, "23": 2.2
    },
    "schedule_recommendation": {
      "stop_time": "20:00",
      "start_time": "08:00",
      "timezone": "Asia/Shanghai",
      "startup_buffer_minutes": 15
    },
    "estimated_savings": {
      "hours_per_day": 12,
      "energy_percentage": 50,
      "cost_monthly_estimate": "待配置电费计算"
    }
  }
}
```

## 5. 健康评分算法

### 5.1 算法原理

**目标：** 评估集群/主机的整体健康状况，识别潜在风险。

**评估维度：**
- 资源均衡度：各主机资源分配是否均衡
- 超配风险：CPU/内存超分配比例
- 热点集中度：是否存在热点主机

### 5.2 评分模型

```go
// 健康评分
type HealthScorer struct {
    weights HealthWeights
}

type HealthWeights struct {
    Balance    float64 // 均衡度权重
    Overcommit float64 // 超配风险权重
    Hotspot    float64 // 热点权重
}

type HealthScore struct {
    Overall      float64
    BalanceScore float64
    OvercommitScore float64
    HotspotScore float64
    Issues       []HealthIssue
    Recommendations []string
}

func (s *HealthScorer) ScoreCluster(cluster *Cluster, hosts []Host) *HealthScore {
    // 1. 计算均衡度评分
    balanceScore := s.calculateBalanceScore(hosts)

    // 2. 计算超配风险评分
    overcommitScore := s.calculateOvercommitScore(cluster, hosts)

    // 3. 计算热点评分
    hotspotScore := s.calculateHotspotScore(hosts)

    // 4. 计算总分
    overall := balanceScore*s.weights.Balance +
        overcommitScore*s.weights.Overcommit +
        hotspotScore*s.weights.Hotspot

    // 5. 识别问题
    issues := s.identifyIssues(hosts, balanceScore, overcommitScore, hotspotScore)

    // 6. 生成建议
    recommendations := s.generateRecommendations(issues)

    return &HealthScore{
        Overall:        overall,
        BalanceScore:   balanceScore,
        OvercommitScore: overcommitScore,
        HotspotScore:   hotspotScore,
        Issues:         issues,
        Recommendations: recommendations,
    }
}

// 均衡度评分
func (s *HealthScorer) calculateBalanceScore(hosts []Host) float64 {
    if len(hosts) == 0 {
        return 0
    }

    // 计算各主机 CPU 使用率
    cpuUsages := make([]float64, len(hosts))
    for i, host := range hosts {
        if host.CPUTotal > 0 {
            cpuUsages[i] = host.CPUUsed / float64(host.CPUTotal)
        }
    }

    // 计算变异系数 (标准差/均值)
    mean := avg(cpuUsages)
    variance := 0.0
    for _, u := range cpuUsages {
        variance += math.Pow(u-mean, 2)
    }
    variance /= float64(len(cpuUsages))
    stdDev := math.Sqrt(variance)

    cv := stdDev / mean

    // CV 越小，均衡度越好
    // CV < 0.2 -> 优秀, CV < 0.4 -> 良好, CV < 0.6 -> 一般
    if cv < 0.2 {
        return 100
    } else if cv < 0.4 {
        return 80
    } else if cv < 0.6 {
        return 60
    } else {
        return max(0, 100-cv*100)
    }
}

// 超配风险评分
func (s *HealthScorer) calculateOvercommitScore(cluster *Cluster, hosts []Host) float64 {
    // 计算集群级超配比例
    totalVCPU := 0
    totalVMem := 0

    for _, host := range hosts {
        totalVCPU += host.TotalVCPU
        totalVMem += host.TotalVMem
    }

    cpuOvercommit := float64(totalVCPU) / float64(cluster.TotalCPU)
    memOvercommit := float64(totalVMem) / float64(cluster.TotalMem)

    // 超配比例越高，分数越低
    cpuScore := s.scoreOvercommit(cpuOvercommit, 2.0, 4.0)
    memScore := s.scoreOvercommit(memOvercommit, 1.5, 2.5)

    return (cpuScore + memScore) / 2
}

func (s *HealthScorer) scoreOvercommit(ratio, optimal, max float64) float64 {
    if ratio <= optimal {
        return 100
    } else if ratio >= max {
        return 0
    } else {
        return 100 * (max - ratio) / (max - optimal)
    }
}

// 热点评分
func (s *HealthScorer) calculateHotspotScore(hosts []Host) float64 {
    if len(hosts) == 0 {
        return 100
    }

    // 找出负载最高的主机
    maxUsage := 0.0
    for _, host := range hosts {
        usage := host.CPUUsed / float64(host.CPUTotal)
        if usage > maxUsage {
            maxUsage = usage
        }
    }

    // 最高负载超过 90% -> 风险高
    if maxUsage > 0.95 {
        return 0
    } else if maxUsage > 0.85 {
        return 50
    } else if maxUsage > 0.75 {
        return 80
    } else {
        return 100
    }
}
```

### 5.3 输出结构

```json
{
  "entity_type": "cluster",
  "entity_id": "cluster-001",
  "entity_name": "Production-Cluster",
  "analysis_type": "health",
  "conclusion": "整体健康，存在部分优化空间",
  "evidence": {
    "overall_score": 82.5,
    "dimensions": {
      "balance": {
        "score": 85.0,
        "description": "资源分配较均衡",
        "cv": 0.18
      },
      "overcommit": {
        "score": 78.0,
        "description": "CPU 超配略高",
        "cpu_overcommit": 2.3,
        "mem_overcommit": 1.4
      },
      "hotspot": {
        "score": 88.0,
        "description": "无明显热点",
        "max_cpu_usage": 0.72
      }
    },
    "hotspots": [],
    "at_risk_hosts": [
      {
        "host_id": "host-005",
        "host_name": "esxi-05",
        "cpu_usage": 0.88,
        "issues": ["CPU 使用率偏高"]
      }
    ],
    "recommendations": [
      "将 host-005 上的部分 VM 迁移到空闲主机",
      "评估当前超配策略，考虑适当降低 CPU 超配比例"
    ]
  }
}
```

## 6. 算法配置

### 6.1 配置参数

| 参数 | 默认值 | 说明 |
|------|--------|------|
| 僵尸 VM 检测窗口 | 14 天 | 数据采集时长 |
| 僵尸 VM CPU 阈值 | 5% | CPU 使用率上限 |
| 僵尸 VM 内存阈值 | 10% | 内存使用率上限 |
| Right Size 分析窗口 | 30 天 | 数据采集时长 |
| Right Size 百分位 | 95 | P95 分析 |
| Right Size 缓冲比例 | 20% | 推荐配置缓冲 |
| 潮汐检测最小数据 | 14 天 | 最少数据天数 |
| 潮汐检测最小峰谷差 | 40% | 最小峰谷差 |

### 6.2 动态配置

```go
// 算法配置
type AlgorithmConfig struct {
    Zombie    ZombieConfig    `json:"zombie"`
    RightSize RightSizeConfig `json:"rightsize"`
    Tidal     TidalConfig     `json:"tidal"`
    Health    HealthConfig    `json:"health"`
}

type ZombieConfig struct {
    DurationDays int     `json:"duration_days"`
    CPUMax       float64 `json:"cpu_max"`
    MemMax       float64 `json:"mem_max"`
    IOMax        float64 `json:"io_max"`
}

// 从数据库加载配置
func LoadAlgorithmConfig(db *sql.DB) (*AlgorithmConfig, error) {
    config := &AlgorithmConfig{}

    // 从 settings 表读取配置
    settings := map[string]string{
        "analysis.zombie.duration_days":    "14",
        "analysis.zombie.cpu_threshold":    "5.0",
        "analysis.zombie.mem_threshold":    "10.0",
        "analysis.rightsize.percentile":    "95",
        "analysis.rightsize.buffer_ratio":  "0.2",
        // ...
    }

    // 解析并填充配置

    return config, nil
}
```

## 7. 变更记录

| 版本 | 日期 | 变更内容 | 作者 |
|------|------|----------|------|
| v1.0 | 2026-02-07 | 初始版本 | - |
