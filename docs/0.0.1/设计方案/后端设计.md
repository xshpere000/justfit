# JustFit 后端设计文档

## 0. 文档信息

| 项目 | 内容 |
|------|------|
| 文档名称 | 后端设计文档 |
| 版本 | v1.0 |
| 日期 | 2026-02-07 |
| 项目版本 | v0.0.1 Beta |
| 技术栈 | Go 1.21+ + Wails v2 |

## 1. 技术架构

### 1.1 技术选型

| 组件 | 技术选型 | 说明 |
|------|----------|------|
| 语言 | Go 1.21+ | 高性能、简洁并发 |
| 框架 | Wails v2 | Go + Web 桌面应用 |
| vCenter SDK | govmomi | VMware 官方 Go SDK |
| 数据库 | SQLite (mattn/go-sqlite3) | 嵌入式数据库 |
| 加密 | crypto/aes | 标准库 AES-256-GCM |
| 日志 | sirupsen/logrus | 结构化日志 |
| 配置 | spf13/viper | 配置管理 |
| 测试 | stretchr/testify | 测试框架 |

### 1.2 目录结构

```
backend/
├── app.go                    # Wails 应用入口
├── main.go                   # 主入口
├── config/                   # 配置管理
│   ├── config.go            # 配置结构定义
│   └── loader.go            # 配置加载器
├── connector/               # 采集连接器
│   ├── manager.go           # 连接器管理器
│   ├── vcenter/             # vCenter 连接器
│   │   ├── client.go        # 客户端封装
│   │   ├── collector.go     # 数据采集
│   │   └── models.go        # 数据模型
│   └── interface.go         # 连接器接口定义
├── etl/                     # 数据治理
│   ├── pipeline.go          # ETL 流水线
│   ├── extractor.go         # 数据提取
│   ├── transformer.go       # 数据转换
│   ├── loader.go            # 数据加载
│   └── validator.go         # 数据验证
├── storage/                 # 存储层
│   ├── database.go          # 数据库连接
│   ├── cluster_repo.go      # 集群仓储
│   ├── host_repo.go         # 主机仓储
│   ├── vm_repo.go           # 虚拟机仓储
│   ├── metrics_repo.go      # 指标仓储
│   └── migrations/          # 数据库迁移
│       └── schema.sql
├── analyzer/                # 分析算法
│   ├── engine.go            # 分析引擎
│   ├── zombie.go            # 僵尸 VM 检测
│   ├── rightsize.go         # Right Size 评估
│   ├── tidal.go             # 潮汐检测
│   ├── health.go            # 健康评分
│   └── interface.go         # 分析器接口
├── report/                  # 报告生成
│   ├── generator.go         # 报告生成器
│   ├── templates/           # 报告模板
│   │   ├── html/
│   │   └── pdf/
│   └── exporters/           # 导出器
│       ├── json.go
│       ├── html.go
│       └── pdf.go
├── task/                    # 任务调度
│   ├── scheduler.go         # 任务调度器
│   ├── queue.go             # 任务队列
│   ├── worker.go            # Worker 池
│   └── models.go            # 任务模型
├── security/                # 安全模块
│   ├── crypto.go            # 加密解密
│   └── credentials.go       # 凭据管理
├── log/                     # 日志管理
│   ├── logger.go            # 日志器
│   └── middleware.go        # 日志中间件
├── models/                  # 数据模型
│   ├── connection.go        # 连接模型
│   ├── cluster.go           # 集群模型
│   ├── host.go              # 主机模型
│   ├── vm.go                # 虚拟机模型
│   ├── metrics.go           # 指标模型
│   ├── task.go              # 任务模型
│   └── report.go            # 报告模型
├── services/                # Wails 服务 (导出给前端)
│   ├── connection_service.go
│   ├── task_service.go
│   ├── analysis_service.go
│   ├── report_service.go
│   └── system_service.go
└── utils/                   # 工具函数
    ├── time.go              # 时间工具
    ├── math.go              # 数学工具
    └── errors.go            # 错误处理
```

## 2. 核心模块设计

### 2.1 连接器模块 (connector)

#### 2.1.1 接口定义

```go
// connector/interface.go
package connector

import (
    "context"
    "time"
)

// Connector 采集器接口
type Connector interface {
    // Connect 建立连接
    Connect(ctx context.Context, config *ConnectionConfig) error

    // Test 测试连接
    Test(ctx context.Context) error

    // Collect 采集数据
    Collect(ctx context.Context, scope *CollectScope) (*CollectResult, error)

    // Disconnect 断开连接
    Disconnect(ctx context.Context) error

    // GetMetadata 获取平台元数据
    GetMetadata(ctx context.Context) (*PlatformMetadata, error)
}

// ConnectionConfig 连接配置
type ConnectionConfig struct {
    Type     string `json:"type"`     // vcenter, h3c
    Endpoint string `json:"endpoint"` // 服务器地址
    Port     int    `json:"port"`     // 端口
    Username string `json:"username"`
    Password string `json:"password"`
    Insecure bool   `json:"insecure"` // 跳过证书验证
}

// CollectScope 采集范围
type CollectScope struct {
    ClusterIDs []string `json:"cluster_ids"`
    HostIDs    []string `json:"host_ids"`
    VMIDs      []string `json:"vm_ids"`
    StartTime  time.Time `json:"start_time"`
    EndTime    time.Time `json:"end_time"`
}

// CollectResult 采集结果
type CollectResult struct {
    Clusters []ClusterData `json:"clusters"`
    Hosts    []HostData    `json:"hosts"`
    VMs      []VMData      `json:"vms"`
    Metrics  []MetricData  `json:"metrics"`
}

// PlatformMetadata 平台元数据
type PlatformMetadata struct {
    Type        string `json:"type"`
    Version     string `json:"version"`
    APIVersion  string `json:"api_version"`
    ServerTime  time.Time `json:"server_time"`
}
```

#### 2.1.2 vCenter 连接器实现

```go
// connector/vcenter/client.go
package vcenter

import (
    "context"
    "github.com/vmware/govmomi"
    "github.com/vmware/govmomi/vim25/soap"
)

type VCenterClient struct {
    client *govmomi.Client
    config *connector.ConnectionConfig
}

func NewVCenterClient(config *connector.ConnectionConfig) *VCenterClient {
    return &VCenterClient{config: config}
}

func (c *VCenterClient) Connect(ctx context.Context) error {
    url, err := soap.ParseURL(c.config.Endpoint)
    if err != nil {
        return err
    }

    url.User = soap.UserPass(c.config.Username, c.config.Password)

    client, err := govmomi.NewClient(ctx, url, c.config.Insecure)
    if err != nil {
        return err
    }

    c.client = client
    return nil
}

func (c *VCenterClient) Test(ctx context.Context) error {
    if c.client == nil {
        if err := c.Connect(ctx); err != nil {
            return err
        }
    }

    // 通过获取服务实例来测试连接
    _, err := c.client.ServiceInstance(ctx)
    return err
}

func (c *VCenterClient) Disconnect(ctx context.Context) error {
    if c.client != nil {
        return c.client.Logout(ctx)
    }
    return nil
}
```

#### 2.1.3 数据采集器

```go
// connector/vcenter/collector.go
package vcenter

import (
    "context"
    "github.com/vmware/govmomi/vim25/mo"
    "github.com/vmware/govmomi/vim25/types"
)

type Collector struct {
    client *VCenterClient
}

func NewCollector(client *VCenterClient) *Collector {
    return &Collector{client: client}
}

// CollectClusters 采集集群数据
func (c *Collector) CollectClusters(ctx context.Context) ([]ClusterData, error) {
    var clusters []mo.ClusterComputeResource
    err := c.client.client.Retrieve(ctx, c.client.client.ServiceContent.RootFolder,
        []string{"ClusterComputeResource"}, &clusters)
    if err != nil {
        return nil, err
    }

    result := make([]ClusterData, 0, len(clusters))
    for _, cluster := range clusters {
        data := ClusterData{
            ID:        cluster.ExtensibleManagedObject.Value(),
            Name:      cluster.Name,
            TotalCPU:  int(*cluster.Summary.TotalCpu),
            TotalMem:  int(*cluster.Summary.TotalMemory / 1024 / 1024), // Byte -> MB
            // ... 其他字段
        }
        result = append(result, data)
    }

    return result, nil
}

// CollectVMs 采集虚拟机数据
func (c *Collector) CollectVMs(ctx context.Context, scope *CollectScope) ([]VMData, error) {
    // 实现细节...
    return nil, nil
}

// CollectMetrics 采集指标数据
func (c *Collector) CollectMetrics(ctx context.Context, scope *CollectScope) ([]MetricData, error) {
    // 使用 perf Manager 获取性能数据
    // 实现细节...
    return nil, nil
}
```

### 2.2 ETL 模块 (etl)

#### 2.2.1 ETL 流水线

```go
// etl/pipeline.go
package etl

import (
    "context"
)

type Pipeline struct {
    extractor   *Extractor
    transformer *Transformer
    loader      *Loader
}

func NewPipeline(db *sql.DB) *Pipeline {
    return &Pipeline{
        extractor:   NewExtractor(),
        transformer: NewTransformer(),
        loader:      NewLoader(db),
    }
}

// Execute 执行 ETL 流程
func (p *Pipeline) Execute(ctx context.Context, data *RawCollectData) error {
    // 1. Extract: 数据提取
    extractedData, err := p.extractor.Extract(ctx, data)
    if err != nil {
        return fmt.Errorf("extract failed: %w", err)
    }

    // 2. Transform: 数据转换
    transformedData, err := p.transformer.Transform(ctx, extractedData)
    if err != nil {
        return fmt.Errorf("transform failed: %w", err)
    }

    // 3. Load: 数据加载
    if err := p.loader.Load(ctx, transformedData); err != nil {
        return fmt.Errorf("load failed: %w", err)
    }

    return nil
}
```

#### 2.2.2 数据转换器

```go
// etl/transformer.go
package etl

type Transformer struct {
    validators []Validator
}

type TransformResult struct {
    Clusters []models.Cluster
    Hosts    []models.Host
    VMs      []models.VM
    Metrics  []models.Metric
    Errors   []TransformError
}

// Transform 执行数据转换
func (t *Transformer) Transform(ctx context.Context, data *ExtractedData) (*TransformResult, error) {
    result := &TransformResult{}

    // 转换集群数据
    for _, rawCluster := range data.Clusters {
        cluster := models.Cluster{
            ID:        rawCluster.ID,
            Name:      rawCluster.Name,
            Vendor:    rawCluster.Vendor,
            TotalCPU:  rawCluster.TotalCPU,
            TotalMem:  rawCluster.TotalMem,
            // ... 单位归一化处理
        }

        // 验证数据
        if errs := t.validateCluster(&cluster); len(errs) > 0 {
            result.Errors = append(result.Errors, errs...)
            continue
        }

        result.Clusters = append(result.Clusters, cluster)
    }

    // 类似处理 Hosts, VMs, Metrics...

    return result, nil
}

// validateCluster 验证集群数据
func (t *Transformer) validateCluster(cluster *models.Cluster) []TransformError {
    var errors []TransformError

    if cluster.ID == "" {
        errors = append(errors, TransformError{
            Field:   "id",
            Message: "cluster ID is required",
        })
    }

    if cluster.TotalCPU < 0 {
        errors = append(errors, TransformError{
            Field:   "total_cpu",
            Message: "total_cpu must be non-negative",
        })
    }

    return errors
}
```

### 2.3 存储模块 (storage)

#### 2.3.1 数据库连接

```go
// storage/database.go
package storage

import (
    "database/sql"
    "github.com/jmoiron/sqlx"
    _ "github.com/mattn/go-sqlite3"
)

type Database struct {
    db *sqlx.DB
    dsn string
}

func NewDatabase(dsn string) (*Database, error) {
    db, err := sqlx.Connect("sqlite3", dsn)
    if err != nil {
        return nil, err
    }

    // 性能优化
    db.SetMaxOpenConns(1) // SQLite 不支持并发写入
    db.SetMaxIdleConns(1)

    return &Database{db: db, dsn: dsn}, nil
}

// InitSchema 初始化数据库结构
func (d *Database) InitSchema() error {
    // 执行 schema.sql
    schema := readSchemaSQL()
    _, err := d.db.Exec(schema)
    return err
}

// Close 关闭数据库连接
func (d *Database) Close() error {
    return d.db.Close()
}

// GetDB 获取数据库连接
func (d *Database) GetDB() *sqlx.DB {
    return d.db
}
```

#### 2.3.2 仓储模式

```go
// storage/vm_repo.go
package storage

import (
    "context"
    "github.com/jmoiron/sqlx"
)

type VMRepository struct {
    db *sqlx.DB
}

func NewVMRepository(db *sqlx.DB) *VMRepository {
    return &VMRepository{db: db}
}

// Create 批量创建虚拟机记录
func (r *VMRepository) Create(ctx context.Context, vms []models.VM) error {
    if len(vms) == 0 {
        return nil
    }

    query := `
        INSERT OR REPLACE INTO vms (
            id, host_id, cluster_id, name, uuid, vcpu, vmem, vdisk,
            os_type, os_version, power_state, ip_address,
            guest_tools_status, is_template, annotations, metadata,
            created_at, updated_at
        ) VALUES (
            :id, :host_id, :cluster_id, :name, :uuid, :vcpu, :vmem, :vdisk,
            :os_type, :os_version, :power_state, :ip_address,
            :guest_tools_status, :is_template, :annotations, :metadata,
            :created_at, :updated_at
        )
    `

    _, err := r.db.NamedExecContext(ctx, query, vms)
    return err
}

// List 查询虚拟机列表
func (r *VMRepository) List(ctx context.Context, filter *VMFilter) ([]models.VM, error) {
    query := `SELECT * FROM vms WHERE 1=1`
    args := make(map[string]interface{})

    if filter.HostID != "" {
        query += " AND host_id = :host_id"
        args["host_id"] = filter.HostID
    }

    if filter.PowerState != "" {
        query += " AND power_state = :power_state"
        args["power_state"] = filter.PowerState
    }

    if filter.Limit > 0 {
        query += " LIMIT :limit"
        args["limit"] = filter.Limit
    }

    query += " OFFSET :offset"
    args["offset"] = filter.Offset

    var vms []models.VM
    err := r.db.SelectContext(ctx, &vms, query, args)
    return vms, err
}

// GetByID 根据 ID 获取虚拟机
func (r *VMRepository) GetByID(ctx context.Context, id string) (*models.VM, error) {
    query := `SELECT * FROM vms WHERE id = ?`
    var vm models.VM
    err := r.db.GetContext(ctx, &vm, query, id)
    if err != nil {
        return nil, err
    }
    return &vm, nil
}

// BatchInsertMetrics 批量插入指标数据
func (r *VMRepository) BatchInsertMetrics(ctx context.Context, metrics []models.Metric) error {
    if len(metrics) == 0 {
        return nil
    }

    tx, err := r.db.BeginTxx(ctx, nil)
    if err != nil {
        return err
    }
    defer tx.Rollback()

    stmt, err := tx.PreparexContext(ctx, `
        INSERT INTO metrics (entity_type, entity_id, metric_name, timestamp, value, unit, created_at)
        VALUES (?, ?, ?, ?, ?, ?, ?)
    `)
    if err != nil {
        return err
    }
    defer stmt.Close()

    for _, m := range metrics {
        _, err := stmt.ExecContext(ctx, m.EntityType, m.EntityID, m.MetricName,
            m.Timestamp, m.Value, m.Unit, m.CreatedAt)
        if err != nil {
            return err
        }
    }

    return tx.Commit()
}
```

### 2.4 分析模块 (analyzer)

#### 2.4.1 分析器接口

```go
// analyzer/interface.go
package analyzer

import (
    "context"
)

type Analyzer interface {
    Name() string
    Type() AnalysisType
    Analyze(ctx context.Context, input *AnalysisInput) (*AnalysisResult, error)
    Validate(input *AnalysisInput) error
}

type AnalysisType string

const (
    AnalysisTypeZombie     AnalysisType = "zombie"
    AnalysisTypeRightSize  AnalysisType = "rightsize"
    AnalysisTypeTidal      AnalysisType = "tidal"
    AnalysisTypeHealth     AnalysisType = "health"
)

type AnalysisInput struct {
    Type       AnalysisType
    EntityType string
    EntityIDs  []string
    StartTime  time.Time
    EndTime    time.Time
    Options    map[string]interface{}
}

type AnalysisResult struct {
    ID         string
    Type       AnalysisType
    Summary    string
    Entries    []AnalysisEntry
    Statistics map[string]int
}
```

#### 2.4.2 僵尸 VM 分析器

```go
// analyzer/zombie.go
package analyzer

type ZombieAnalyzer struct {
    db        *sqlx.DB
    thresholds ZombieThresholds
}

type ZombieThresholds struct {
    CPUMax      float64 // 最大 CPU 使用率 %
    MemMax      float64 // 最大内存使用率 %
    IOMax       float64 // 最大 IO (IOPS)
    DurationDay int     // 持续天数
}

func NewZombieAnalyzer(db *sqlx.DB) *ZombieAnalyzer {
    return &ZombieAnalyzer{
        db: db,
        thresholds: ZombieThresholds{
            CPUMax:      5.0,
            MemMax:      10.0,
            IOMax:       10.0,
            DurationDay: 14,
        },
    }
}

func (a *ZombieAnalyzer) Name() string {
    return "Zombie VM Detector"
}

func (a *ZombieAnalyzer) Type() AnalysisType {
    return AnalysisTypeZombie
}

func (a *ZombieAnalyzer) Analyze(ctx context.Context, input *AnalysisInput) (*AnalysisResult, error) {
    // 1. 获取目标 VM 列表
    vms, err := a.getTargetVMs(ctx, input)
    if err != nil {
        return nil, err
    }

    result := &AnalysisResult{
        Type:    AnalysisTypeZombie,
        Entries: make([]AnalysisEntry, 0),
    }

    // 2. 对每个 VM 进行检测
    for _, vm := range vms {
        entry, err := a.analyzeVM(ctx, &vm)
        if err != nil {
            continue
        }

        if entry != nil {
            result.Entries = append(result.Entries, *entry)
        }
    }

    // 3. 生成统计摘要
    result.Statistics = a.calculateStatistics(result.Entries)
    result.Summary = a.generateSummary(result.Statistics)

    return result, nil
}

// analyzeVM 分析单个 VM
func (a *ZombieAnalyzer) analyzeVM(ctx context.Context, vm *models.VM) (*AnalysisEntry, error) {
    // 获取时间窗口内的指标数据
    endTime := time.Now()
    startTime := endTime.AddDate(0, 0, -a.thresholds.DurationDay)

    metrics, err := a.getVMMetrics(ctx, vm.ID, startTime, endTime)
    if err != nil {
        return nil, err
    }

    // 计算统计数据
    stats := a.calculateMetricsStats(metrics)

    // 判定是否为僵尸 VM
    if a.isZombieVM(stats) {
        return &AnalysisEntry{
            EntityType:    "vm",
            EntityID:      vm.ID,
            EntityName:    vm.Name,
            Conclusion:    "检测为僵尸虚拟机",
            Confidence:    a.calculateConfidence(stats),
            Recommendation: "建议关机或迁移至低配主机",
            Evidence:      a.buildEvidence(stats),
            RiskLevel:     "medium",
        }, nil
    }

    return nil, nil
}

// isZombieVM 判定是否为僵尸 VM
func (a *ZombieAnalyzer) isZombieVM(stats *MetricsStats) bool {
    return stats.CPU.Mean <= a.thresholds.CPUMax &&
        stats.Memory.Mean <= a.thresholds.MemMax &&
        stats.DiskIO.IOPSMean <= a.thresholds.IOMax
}
```

#### 2.4.3 Right Size 分析器

```go
// analyzer/rightsize.go
package analyzer

type RightSizeAnalyzer struct {
    db         *sqlx.DB
    percentile int // 分析百分位，默认 95
}

func NewRightSizeAnalyzer(db *sqlx.DB) *RightSizeAnalyzer {
    return &RightSizeAnalyzer{
        db:         db,
        percentile: 95,
    }
}

func (a *RightSizeAnalyzer) Analyze(ctx context.Context, input *AnalysisInput) (*AnalysisResult, error) {
    vms, err := a.getTargetVMs(ctx, input)
    if err != nil {
        return nil, err
    }

    result := &AnalysisResult{
        Type:    AnalysisTypeRightSize,
        Entries: make([]AnalysisEntry, 0),
    }

    for _, vm := range vms {
        entry, err := a.analyzeVM(ctx, &vm)
        if err != nil {
            continue
        }

        // 只记录有调整建议的 VM
        if entry != nil {
            result.Entries = append(result.Entries, *entry)
        }
    }

    return result, nil
}

// analyzeVM 分析单个 VM 的资源配置
func (a *RightSizeAnalyzer) analyzeVM(ctx context.Context, vm *models.VM) (*AnalysisEntry, error) {
    // 获取 30 天历史数据
    endTime := time.Now()
    startTime := endTime.AddDate(0, 0, -30)

    metrics, err := a.getVMMetrics(ctx, vm.ID, startTime, endTime)
    if err != nil {
        return nil, err
    }

    // 计算推荐配置
    recommendation := a.calculateRecommendation(vm, metrics)

    // 判断是否需要调整
    if recommendation.NeedsAdjustment {
        return &AnalysisEntry{
            EntityType:     "vm",
            EntityID:       vm.ID,
            EntityName:     vm.Name,
            Conclusion:     "资源配置不合理",
            Confidence:     0.9,
            Recommendation: a.buildRecommendationText(recommendation),
            Evidence:       a.buildEvidence(vm, recommendation),
            Savings:        a.calculateSavings(vm, recommendation),
            RiskLevel:      a.assessRisk(recommendation),
        }, nil
    }

    return nil, nil
}

// calculateRecommendation 计算推荐配置
func (a *RightSizeAnalyzer) calculateRecommendation(
    vm *models.VM,
    metrics []models.Metric,
) *RightSizeRecommendation {
    // 提取 CPU 和内存使用率
    cpuUsages := extractMetricValues(metrics, "cpu.usage_pct")
    memUsages := extractMetricValues(metrics, "mem.usage_pct")

    // 计算 P95 值
    cpuP95 := percentile(cpuUsages, a.percentile)
    memP95 := percentile(memUsages, a.percentile)

    // 计算推荐配置 (留 20% buffer)
    recommendedVCPU := int(math.Ceil(float64(vm.VCPU) * cpuP95 / 100 * 1.2))
    recommendedMem := int(math.Ceil(float64(vm.VMem) * memP95 / 100 * 1.2))

    // 确保最小值
    if recommendedVCPU < 1 {
        recommendedVCPU = 1
    }
    if recommendedMem < 512 {
        recommendedMem = 512
    }

    return &RightSizeRecommendation{
        Current: ResourceConfig{
            VCPU: vm.VCPU,
            Mem:  vm.VMem,
        },
        Recommended: ResourceConfig{
            VCPU: recommendedVCPU,
            Mem:  recommendedMem,
        },
        CPUP95:    cpuP95,
        MemP95:    memP95,
        NeedsAdjustment: recommendedVCPU != vm.VCPU || recommendedMem != vm.VMem,
    }
}
```

### 2.5 任务调度模块 (task)

#### 2.5.1 任务调度器

```go
// task/scheduler.go
package task

import (
    "context"
    "sync"
)

type Scheduler struct {
    queue     chan *Task
    workers   []*Worker
    taskStore *TaskStore
    wg        sync.WaitGroup
    ctx       context.Context
    cancel    context.CancelFunc
    maxWorkers int
}

func NewScheduler(db *sqlx.DB, maxWorkers int) *Scheduler {
    ctx, cancel := context.WithCancel(context.Background())

    return &Scheduler{
        queue:      make(chan *Task, 100),
        workers:    make([]*Worker, 0, maxWorkers),
        taskStore:  NewTaskStore(db),
        ctx:        ctx,
        cancel:     cancel,
        maxWorkers: maxWorkers,
    }
}

// Start 启动调度器
func (s *Scheduler) Start() error {
    for i := 0; i < s.maxWorkers; i++ {
        worker := NewWorker(i, s.queue, s.taskStore)
        s.workers = append(s.workers, worker)

        s.wg.Add(1)
        go func(w *Worker) {
            defer s.wg.Done()
            w.Run(s.ctx)
        }(worker)
    }

    // 恢复未完成的任务
    return s.recoverPendingTasks()
}

// Stop 停止调度器
func (s *Scheduler) Stop() {
    s.cancel()
    s.wg.Wait()
}

// Submit 提交任务
func (s *Scheduler) Submit(task *Task) error {
    // 保存到数据库
    if err := s.taskStore.Create(task); err != nil {
        return err
    }

    // 加入队列
    select {
    case s.queue <- task:
        return nil
    default:
        return errors.New("task queue is full")
    }
}
```

#### 2.5.2 Worker 实现

```go
// task/worker.go
package task

type Worker struct {
    id        int
    queue     chan *Task
    taskStore *TaskStore
}

func NewWorker(id int, queue chan *Task, store *TaskStore) *Worker {
    return &Worker{
        id:        id,
        queue:     queue,
        taskStore: store,
    }
}

// Run 运行 Worker
func (w *Worker) Run(ctx context.Context) {
    for {
        select {
        case <-ctx.Done():
            return
        case task := <-w.queue:
            w.executeTask(ctx, task)
        }
    }
}

// executeTask 执行任务
func (w *Worker) executeTask(ctx context.Context, task *Task) {
    // 更新任务状态
    task.Status = TaskStatusRunning
    task.StartedAt = time.Now()
    w.taskStore.Update(task)

    // 执行任务
    executor := w.getExecutor(task.Type)
    result, err := executor.Execute(ctx, task)

    // 更新任务结果
    task.EndedAt = time.Now()
    if err != nil {
        task.Status = TaskStatusFailed
        task.ErrorMsg = err.Error()
    } else {
        task.Status = TaskStatusSuccess
        task.Result = result
    }

    w.taskStore.Update(task)
}

// getExecutor 获取任务执行器
func (w *Worker) getExecutor(taskType TaskType) TaskExecutor {
    switch taskType {
    case TaskTypeCollect:
        return &CollectTaskExecutor{}
    case TaskTypeAnalyze:
        return &AnalyzeTaskExecutor{}
    case TaskTypeReport:
        return &ReportTaskExecutor{}
    default:
        return nil
    }
}
```

### 2.6 安全模块 (security)

#### 2.6.1 加密工具

```go
// security/crypto.go
package security

import (
    "crypto/aes"
    "crypto/cipher"
    "crypto/rand"
    "io"
)

type Crypto struct {
    key []byte
}

func NewCrypto(key []byte) *Crypto {
    // 确保密钥长度为 32 字节 (AES-256)
    if len(key) < 32 {
        padded := make([]byte, 32)
        copy(padded, key)
        key = padded
    }
    return &Crypto{key: key[:32]}
}

// Encrypt 加密数据
func (c *Crypto) Encrypt(plaintext []byte) ([]byte, error) {
    block, err := aes.NewCipher(c.key)
    if err != nil {
        return nil, err
    }

    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return nil, err
    }

    nonce := make([]byte, gcm.NonceSize())
    if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
        return nil, err
    }

    ciphertext := gcm.Seal(nonce, nonce, plaintext, nil)
    return ciphertext, nil
}

// Decrypt 解密数据
func (c *Crypto) Decrypt(ciphertext []byte) ([]byte, error) {
    block, err := aes.NewCipher(c.key)
    if err != nil {
        return nil, err
    }

    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return nil, err
    }

    nonceSize := gcm.NonceSize()
    if len(ciphertext) < nonceSize {
        return nil, errors.New("ciphertext too short")
    }

    nonce, ciphertext := ciphertext[:nonceSize], ciphertext[nonceSize:]
    plaintext, err := gcm.Open(nil, nonce, ciphertext, nil)
    if err != nil {
        return nil, err
    }

    return plaintext, nil
}
```

### 2.7 Wails 服务 (services)

#### 2.7.1 连接服务

```go
// services/connection_service.go
package services

import (
    "context"
    "github.com/wailsapp/wails/v2/pkg/runtime"
)

type ConnectionService struct {
    ctx         context.Context
    connManager *connector.Manager
    connRepo    *storage.ConnectionRepository
    crypto      *security.Crypto
}

func NewConnectionService(
    connManager *connector.Manager,
    connRepo *storage.ConnectionRepository,
    crypto *security.Crypto,
) *ConnectionService {
    return &ConnectionService{
        connManager: connManager,
        connRepo:    connRepo,
        crypto:      crypto,
    }
}

// SetContext Wails 注入上下文
func (s *ConnectionService) SetContext(ctx context.Context) {
    s.ctx = ctx
}

// CreateConnection 创建连接
func (s *ConnectionService) CreateConnection(req *CreateConnectionRequest) (*CreateConnectionResponse, error) {
    // 验证参数
    if err := s.validateRequest(req); err != nil {
        return nil, err
    }

    // 创建连接模型
    conn := &models.Connection{
        ID:       uuid.New().String(),
        Name:     req.Name,
        Type:     req.Type,
        Endpoint: req.Endpoint,
        Status:   "disconnected",
    }

    // 加密凭据
    credentials := map[string]string{
        "username": req.Username,
        "password": req.Password,
    }
    credJSON, _ := json.Marshal(credentials)

    encrypted, err := s.crypto.Encrypt(credJSON)
    if err != nil {
        return nil, err
    }

    // 保存连接
    if err := s.connRepo.Create(s.ctx, conn); err != nil {
        return nil, err
    }

    // 保存凭据
    cred := &models.Credential{
        ConnectionID:  conn.ID,
        EncryptedData: encrypted,
    }
    // ... 保存凭据到数据库

    return &CreateConnectionResponse{
        ID:   conn.ID,
        Name: conn.Name,
    }, nil
}

// ListConnections 获取连接列表
func (s *ConnectionService) ListConnections() (*ListConnectionsResponse, error) {
    connections, err := s.connRepo.List(s.ctx)
    if err != nil {
        return nil, err
    }

    result := make([]ConnectionInfo, 0, len(connections))
    for _, conn := range connections {
        result = append(result, ConnectionInfo{
            ID:          conn.ID,
            Name:        conn.Name,
            Type:        conn.Type,
            Endpoint:    conn.Endpoint,
            Status:      conn.Status,
            LastSyncAt:  conn.LastSyncAt,
            CreatedAt:   conn.CreatedAt,
        })
    }

    return &ListConnectionsResponse{Connections: result}, nil
}

// TestConnection 测试连接
func (s *ConnectionService) TestConnection(req *TestConnectionRequest) (*TestConnectionResponse, error) {
    start := time.Now()

    // 创建测试连接
    config := &connector.ConnectionConfig{
        Type:     req.Type,
        Endpoint: req.Endpoint,
        Username: req.Username,
        Password: req.Password,
    }

    // 获取连接器
    connClient, err := s.connManager.GetConnector(req.Type)
    if err != nil {
        return &TestConnectionResponse{
            Success: false,
            Message: err.Error(),
        }, nil
    }

    // 测试连接
    ctx, cancel := context.WithTimeout(s.ctx, 30*time.Second)
    defer cancel()

    if err := connClient.Connect(ctx, config); err != nil {
        return &TestConnectionResponse{
            Success: false,
            Message: err.Error(),
        }, nil
    }
    defer connClient.Disconnect(ctx)

    latency := time.Since(start).Milliseconds()

    return &TestConnectionResponse{
        Success:       true,
        Message:       "连接成功",
        Latency:       latency,
        ServerVersion: "vCenter 7.0.3", // 从连接获取
    }, nil
}
```

## 3. 错误处理

### 3.1 错误定义

```go
// utils/errors.go
package utils

type AppError struct {
    Code    int
    Message string
    Cause   error
}

func (e *AppError) Error() string {
    if e.Cause != nil {
        return fmt.Sprintf("[%d] %s: %v", e.Code, e.Message, e.Cause)
    }
    return fmt.Sprintf("[%d] %s", e.Code, e.Message)
}

// 预定义错误
var (
    ErrConnectionNotFound = &AppError{Code: 404, Message: "连接不存在"}
    ErrConnectionFailed  = &AppError{Code: 1001, Message: "连接失败"}
    ErrInvalidParam      = &AppError{Code: 400, Message: "参数错误"}
    ErrTaskNotFound      = &AppError{Code: 404, Message: "任务不存在"}
)
```

## 4. 配置管理

### 4.1 配置结构

```go
// config/config.go
package config

type Config struct {
    App      AppConfig      `mapstructure:"app"`
    Database DatabaseConfig `mapstructure:"database"`
    Log      LogConfig      `mapstructure:"log"`
    Security SecurityConfig `mapstructure:"security"`
}

type AppConfig struct {
    Name        string `mapstructure:"name"`
    Version     string `mapstructure:"version"`
    Environment string `mapstructure:"environment"`
    DataDir     string `mapstructure:"data_dir"`
}

type DatabaseConfig struct {
    DSN             string `mapstructure:"dsn"`
    MaxConnections  int    `mapstructure:"max_connections"`
    ConnMaxLifetime int    `mapstructure:"conn_max_lifetime"`
}

type LogConfig struct {
    Level  string `mapstructure:"level"`
    Format string `mapstructure:"format"`
    File   string `mapstructure:"file"`
}

type SecurityConfig struct {
    EncryptionKey string `mapstructure:"encryption_key"`
}
```

## 5. 变更记录

| 版本 | 日期 | 变更内容 | 作者 |
|------|------|----------|------|
| v1.0 | 2026-02-07 | 初始版本 | - |
