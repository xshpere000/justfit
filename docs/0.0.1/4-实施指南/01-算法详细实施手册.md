# JustFit ç®—æ³•è¯¦ç»†å®æ–½æ‰‹å†Œ

## 0. æ–‡æ¡£ä¿¡æ¯

| é¡¹ç›® | å†…å®¹ |
|------|------|
| æ–‡æ¡£åç§° | ç®—æ³•è¯¦ç»†å®æ–½æ‰‹å†Œ |
| ç‰ˆæœ¬ | v1.0 |
| æ—¥æœŸ | 2026-02-08 |
| é¡¹ç›®ç‰ˆæœ¬ | v0.0.1 Beta |
| çŠ¶æ€ | å·²ç¡®è®¤ |

## 1. åƒµå°¸VMæ£€æµ‹ç®—æ³•è¯¦ç»†å®æ–½

### 1.1 ç®—æ³•ç›®æ ‡

è¯†åˆ«é•¿æœŸä½è´Ÿè½½ã€æ— å®é™…ä¸šåŠ¡ä»·å€¼çš„è™šæ‹Ÿæœºï¼Œæä¾›å…³æœºæˆ–èµ„æºå›æ”¶å»ºè®®ã€‚

### 1.2 æ•°æ®éœ€æ±‚

| æ•°æ®ç±»å‹ | å¿…éœ€/å¯é€‰ | æ•°æ®æ ¼å¼ | ç”¨é€” |
|---------|----------|---------|------|
| VMåŸºæœ¬ä¿¡æ¯ | å¿…éœ€ | VMKey, Name, CPUCount, MemoryMB, PowerState | åŸºç¡€æ ‡è¯†å’Œé…ç½® |
| CPUæŒ‡æ ‡ | å¿…éœ€ | æ—¶é—´åºåˆ—ï¼ˆç»å¯¹å€¼ + ç™¾åˆ†æ¯”ï¼‰ | è´Ÿè½½åˆ¤å®šæ ¸å¿ƒæŒ‡æ ‡ |
| å†…å­˜æŒ‡æ ‡ | å¿…éœ€ | æ—¶é—´åºåˆ—ï¼ˆç»å¯¹å€¼ + ç™¾åˆ†æ¯”ï¼‰ | è´Ÿè½½åˆ¤å®šæ ¸å¿ƒæŒ‡æ ‡ |
| ç£ç›˜IOæŒ‡æ ‡ | å¯é€‰ | æ—¶é—´åºåˆ—ï¼ˆIOPSï¼‰ | ä¸šåŠ¡æ´»åŠ¨è¾…åŠ©åˆ¤æ–­ |
| ç½‘ç»œæµé‡æŒ‡æ ‡ | å¯é€‰ | æ—¶é—´åºåˆ—ï¼ˆKB/sï¼‰ | ä¸šåŠ¡æ´»åŠ¨è¾…åŠ©åˆ¤æ–­ |
| VMåˆ›å»ºæ—¶é—´ | å¯é€‰ | Timestamp | æ’é™¤æ–°å»ºVM |

### 1.3 ç®—æ³•æµç¨‹å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               åƒµå°¸VMæ£€æµ‹å®Œæ•´æµç¨‹                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

è¾“å…¥å‚æ•°:
  - connectionID: uint
  - config: *ZombieVMConfig

Step 1: æ•°æ®å‡†å¤‡
â”œâ”€ 1.1 è·å–æ‰€æœ‰VMåˆ—è¡¨
â”‚  â””â”€ SELECT * FROM vms WHERE connection_id = ? AND power_state = 'poweredOn'
â”‚
â”œâ”€ 1.2 è¿‡æ»¤æ¡ä»¶æ£€æŸ¥
â”‚  â”œâ”€ è·³è¿‡å·²å…³æœºçš„VM
â”‚  â”œâ”€ è·³è¿‡æ¨¡æ¿VMï¼ˆå¦‚æœæœ‰æ ‡è®°ï¼‰
â”‚  â””â”€ è·³è¿‡è¿‘æœŸæ–°å»ºçš„VMï¼ˆæ ¹æ® ExcludeRecentStartedï¼‰
â”‚
â””â”€ 1.3 ç¡®å®šæ—¶é—´çª—å£
   â””â”€ endTime = now(), startTime = now() - config.AnalysisDays

Step 2: é€VMåˆ†æå¾ªç¯
FOR EACH vm IN vms:
    
    2.1 è·å–æŒ‡æ ‡æ•°æ®
    â”œâ”€ cpuMetrics = QueryMetrics(vm.ID, "cpu", startTime, endTime)
    â”œâ”€ memMetrics = QueryMetrics(vm.ID, "memory", startTime, endTime)
    â”œâ”€ diskIOMetrics = QueryMetrics(vm.ID, "disk_*", startTime, endTime) [å¯é€‰]
    â””â”€ netMetrics = QueryMetrics(vm.ID, "net_*", startTime, endTime) [å¯é€‰]
    
    2.2 æ•°æ®å®Œæ•´æ€§æ£€æŸ¥
    IF len(cpuMetrics) == 0 OR len(memMetrics) == 0:
        SKIP (æ•°æ®ä¸è¶³ï¼Œæ— æ³•åˆ†æ)
    
    2.3 è®¡ç®—å¹³å‡ä½¿ç”¨ç‡ï¼ˆç™¾åˆ†æ¯”ï¼‰
    â”œâ”€ avgCPUPercent = Average(cpuMetrics.percentage)
    â”œâ”€ avgMemPercent = Average(memMetrics.percentage)
    â”œâ”€ avgDiskIOPS = Average(diskIOMetrics.absolute_value) [å¯é€‰]
    â””â”€ avgNetKBs = Average((netRxMetrics + netTxMetrics).absolute_value) [å¯é€‰]
    
    2.4 æŒ‰å¤©åˆ†ç»„è®¡ç®—ä½è´Ÿè½½å¤©æ•°
    dailyStats = GroupByDay(cpuMetrics, memMetrics)
    lowUsageDays = 0
    
    FOR EACH day IN dailyStats:
        dailyAvgCPU = Average(day.cpuValues)
        dailyAvgMem = Average(day.memValues)
        
        IF dailyAvgCPU < config.CPUThreshold AND 
           dailyAvgMem < config.MemoryThreshold:
            lowUsageDays++
    
    2.5 è®¡ç®—ä½è´Ÿè½½å¤©æ•°æ¯”ä¾‹
    lowUsageDayRatio = lowUsageDays / TotalDays
    
    2.6 åˆ¤å®šæ˜¯å¦ä¸ºåƒµå°¸VM
    isZombie = (
        avgCPUPercent <= config.CPUThreshold AND
        avgMemPercent <= config.MemoryThreshold AND
        avgDiskIOPS <= config.DiskIOThreshold AND      [å¦‚æœæœ‰æ•°æ®]
        avgNetKBs <= config.NetworkThreshold AND       [å¦‚æœæœ‰æ•°æ®]
        lowUsageDayRatio >= config.LowUsageDayRatio
    )
    
    IF NOT isZombie:
        CONTINUE (ä¸æ»¡è¶³æ¡ä»¶ï¼Œè·³è¿‡)
    
    2.7 è®¡ç®—ç½®ä¿¡åº¦
    confidence = CalculateConfidence(
        avgCPUPercent, 
        avgMemPercent,
        avgDiskIOPS,
        avgNetKBs,
        lowUsageDays,
        TotalDays,
        config
    )
    
    IF confidence < config.MinConfidence:
        CONTINUE (ç½®ä¿¡åº¦ä¸è¶³ï¼Œè·³è¿‡)
    
    2.8 ç”Ÿæˆè¯æ®å’Œå»ºè®®
    evidence = BuildEvidence(...)
    recommendation = BuildRecommendation(vm.Name, confidence)
    
    2.9 æ·»åŠ åˆ°ç»“æœé›†
    results.append(ZombieVMResult{...})

Step 3: è¿”å›ç»“æœ
RETURN results

```

### 1.4 å…³é”®å‡½æ•°è¯¦ç»†å®ç°

#### 1.4.1 ç½®ä¿¡åº¦è®¡ç®—ç®—æ³•

```go
// CalculateConfidence è®¡ç®—åƒµå°¸VMç½®ä¿¡åº¦
//
// ç®—æ³•è¯´æ˜ï¼š
// é‡‡ç”¨å¤šç»´åº¦åŠ æƒè¯„åˆ†æ–¹å¼ï¼Œæ€»åˆ†100åˆ†ï¼ŒåŒ…å«ä»¥ä¸‹ç»´åº¦ï¼š
// 1. CPUä½¿ç”¨ç‡è¯„åˆ†ï¼ˆæƒé‡40%ï¼‰
// 2. å†…å­˜ä½¿ç”¨ç‡è¯„åˆ†ï¼ˆæƒé‡30%ï¼‰
// 3. ç£ç›˜IOè¯„åˆ†ï¼ˆæƒé‡15%ï¼‰
// 4. ç½‘ç»œæµé‡è¯„åˆ†ï¼ˆæƒé‡15%ï¼‰
// 5. æŒç»­æ€§åŠ æˆï¼ˆæœ€å¤š+10åˆ†ï¼‰
//
// å‚æ•°:
//   - cpuPercent: å¹³å‡CPUä½¿ç”¨ç‡ (%)
//   - memPercent: å¹³å‡å†…å­˜ä½¿ç”¨ç‡ (%)
//   - diskIOPS: å¹³å‡ç£ç›˜IOPS
//   - netKBs: å¹³å‡ç½‘ç»œæµé‡ (KB/s)
//   - lowDays: ä½è´Ÿè½½å¤©æ•°
//   - totalDays: æ€»åˆ†æå¤©æ•°
//   - config: é…ç½®å‚æ•°ï¼ˆç”¨äºé˜ˆå€¼æ¯”è¾ƒï¼‰
//
// è¿”å›:
//   - confidence: ç½®ä¿¡åº¦åˆ†æ•° (0-100)
//
func CalculateConfidence(
    cpuPercent, memPercent, diskIOPS, netKBs float64,
    lowDays, totalDays int,
    config *ZombieVMConfig,
) float64 {
    
    score := 0.0
    
    // ========== CPUä½¿ç”¨ç‡è¯„åˆ† (40åˆ†) ==========
    // åˆ†çº§è¯„åˆ†ï¼šä½¿ç”¨ç‡è¶Šä½ï¼Œåˆ†æ•°è¶Šé«˜
    cpuScore := 0.0
    if cpuPercent <= config.CPUThreshold * 0.5 {
        // CPUä½¿ç”¨ç‡æä½ï¼ˆ<é˜ˆå€¼ä¸€åŠï¼‰ï¼Œæ»¡åˆ†
        cpuScore = 40.0
    } else if cpuPercent <= config.CPUThreshold * 0.8 {
        // CPUä½¿ç”¨ç‡å¾ˆä½ï¼ˆ<é˜ˆå€¼80%ï¼‰ï¼Œé«˜åˆ†
        cpuScore = 35.0
    } else if cpuPercent <= config.CPUThreshold {
        // CPUä½¿ç”¨ç‡ä½ï¼ˆ<=é˜ˆå€¼ï¼‰ï¼ŒåŠæ ¼åˆ†
        cpuScore = 25.0
    } else {
        // ä¸æ»¡è¶³æ¡ä»¶ï¼Œä½åˆ†ï¼ˆç†è®ºä¸Šä¸åº”è¯¥åˆ°è¿™ï¼‰
        cpuScore = 10.0
    }
    score += cpuScore
    
    // ========== å†…å­˜ä½¿ç”¨ç‡è¯„åˆ† (30åˆ†) ==========
    memScore := 0.0
    if memPercent <= config.MemoryThreshold * 0.5 {
        memScore = 30.0
    } else if memPercent <= config.MemoryThreshold * 0.8 {
        memScore = 25.0
    } else if memPercent <= config.MemoryThreshold {
        memScore = 20.0
    } else {
        memScore = 10.0
    }
    score += memScore
    
    // ========== ç£ç›˜IOè¯„åˆ† (15åˆ†) ==========
    // å¦‚æœæ²¡æœ‰ç£ç›˜æ•°æ®ï¼Œé»˜è®¤ç»™ä¸­ç­‰åˆ†æ•°
    diskScore := 10.0
    if diskIOPS >= 0 { // æœ‰æ•°æ®
        if diskIOPS <= config.DiskIOThreshold * 0.5 {
            diskScore = 15.0
        } else if diskIOPS <= config.DiskIOThreshold {
            diskScore = 12.0
        } else {
            diskScore = 5.0
        }
    }
    score += diskScore
    
    // ========== ç½‘ç»œæµé‡è¯„åˆ† (15åˆ†) ==========
    netScore := 10.0
    if netKBs >= 0 { // æœ‰æ•°æ®
        if netKBs <= config.NetworkThreshold * 0.5 {
            netScore = 15.0
        } else if netKBs <= config.NetworkThreshold {
            netScore = 12.0
        } else {
            netScore = 5.0
        }
    }
    score += netScore
    
    // ========== æŒç»­æ€§åŠ æˆ (æœ€å¤š+10åˆ†) ==========
    // ä½è´Ÿè½½æŒç»­æ—¶é—´è¶Šé•¿ï¼Œç½®ä¿¡åº¦è¶Šé«˜
    if totalDays > 0 {
        dayRatio := float64(lowDays) / float64(totalDays)
        
        if dayRatio >= 0.95 {
            score += 10.0  // 95%ä»¥ä¸ŠæŒç»­ä½è´Ÿè½½ï¼Œæœ€é«˜åŠ æˆ
        } else if dayRatio >= 0.90 {
            score += 8.0
        } else if dayRatio >= 0.85 {
            score += 6.0
        } else if dayRatio >= 0.80 {
            score += 4.0
        } else if dayRatio >= 0.75 {
            score += 2.0
        }
    }
    
    // ç¡®ä¿åˆ†æ•°åœ¨ 0-100 èŒƒå›´å†…
    return math.Min(100.0, math.Max(0.0, score))
}
```

#### 1.4.2 è¯æ®ç”Ÿæˆ

```go
// BuildEvidence æ„å»ºè¯æ®åˆ—è¡¨
//
// ç”Ÿæˆäººç±»å¯è¯»çš„è¯æ®è¯´æ˜ï¼Œç”¨äºæŠ¥å‘Šå’Œå®¡è®¡
//
func BuildEvidence(
    cpuPercent, memPercent, diskIOPS, netKBs float64,
    lowDays, totalDays int,
    config *ZombieVMConfig,
) []string {
    
    evidence := []string{}
    
    // CPUè¯æ®
    if cpuPercent < config.CPUThreshold {
        evidence = append(evidence, fmt.Sprintf(
            "âœ“ CPUä½¿ç”¨ç‡ %.2f%% ä½äºé˜ˆå€¼ %.2f%%",
            cpuPercent,
            config.CPUThreshold,
        ))
        
        // ç‰¹åˆ«ä½çš„æƒ…å†µ
        if cpuPercent < config.CPUThreshold * 0.5 {
            evidence = append(evidence, fmt.Sprintf(
                "  â†’ CPUä½¿ç”¨ç‡æä½ï¼Œä»…ä¸ºé˜ˆå€¼çš„ %.0f%%",
                (cpuPercent / config.CPUThreshold) * 100,
            ))
        }
    }
    
    // å†…å­˜è¯æ®
    if memPercent < config.MemoryThreshold {
        evidence = append(evidence, fmt.Sprintf(
            "âœ“ å†…å­˜ä½¿ç”¨ç‡ %.2f%% ä½äºé˜ˆå€¼ %.2f%%",
            memPercent,
            config.MemoryThreshold,
        ))
    }
    
    // ç£ç›˜IOè¯æ®
    if diskIOPS >= 0 && diskIOPS < config.DiskIOThreshold {
        evidence = append(evidence, fmt.Sprintf(
            "âœ“ ç£ç›˜IO %.2f IOPS ä½äºé˜ˆå€¼ %.2f",
            diskIOPS,
            config.DiskIOThreshold,
        ))
        
        if diskIOPS < 1.0 {
            evidence = append(evidence, 
                "  â†’ ç£ç›˜å‡ ä¹æ— æ´»åŠ¨",
            )
        }
    }
    
    // ç½‘ç»œè¯æ®
    if netKBs >= 0 && netKBs < config.NetworkThreshold {
        evidence = append(evidence, fmt.Sprintf(
            "âœ“ ç½‘ç»œæµé‡ %.2f KB/s ä½äºé˜ˆå€¼ %.2f",
            netKBs,
            config.NetworkThreshold,
        ))
    }
    
    // æŒç»­æ€§è¯æ®
    if totalDays > 0 {
        dayRatio := float64(lowDays) / float64(totalDays)
        evidence = append(evidence, fmt.Sprintf(
            "âœ“ åœ¨è¿‡å» %d å¤©ä¸­ï¼Œæœ‰ %d å¤©ï¼ˆ%.1f%%ï¼‰å¤„äºä½è´Ÿè½½çŠ¶æ€",
            totalDays,
            lowDays,
            dayRatio * 100,
        ))
    }
    
    // æ•°æ®è´¨é‡è¯´æ˜
    evidence = append(evidence, fmt.Sprintf(
        "ğŸ“Š æ•°æ®åŸºäº %d å¤©çš„æŒç»­ç›‘æ§ï¼Œå…± %d ä¸ªæ•°æ®é‡‡æ ·ç‚¹",
        totalDays,
        len(metrics), // è¿™é‡Œéœ€è¦ä¼ å…¥å®é™…çš„æ ·æœ¬æ•°
    ))
    
    return evidence
}
```

#### 1.4.3 å»ºè®®ç”Ÿæˆ

```go
// BuildRecommendation æ„å»ºæ“ä½œå»ºè®®
//
// æ ¹æ®ç½®ä¿¡åº¦ç”Ÿæˆä¸åŒçº§åˆ«çš„å»ºè®®
//
func BuildRecommendation(vmName string, confidence float64) string {
    if confidence >= 95 {
        return fmt.Sprintf(
            "ã€å¼ºçƒˆå»ºè®®ã€‘è™šæ‹Ÿæœº '%s' ææœ‰å¯èƒ½æ˜¯åƒµå°¸æœºï¼ˆç½®ä¿¡åº¦ %.1f%%ï¼‰ï¼Œå»ºè®®ç«‹å³å…³æœºæˆ–åˆ é™¤ï¼Œé‡Šæ”¾èµ„æºã€‚",
            vmName, confidence,
        )
    } else if confidence >= 90 {
        return fmt.Sprintf(
            "ã€å»ºè®®ã€‘è™šæ‹Ÿæœº '%s' å¾ˆå¯èƒ½æ˜¯åƒµå°¸æœºï¼ˆç½®ä¿¡åº¦ %.1f%%ï¼‰ï¼Œå»ºè®®è”ç³»ä¸šåŠ¡æ–¹ç¡®è®¤åå¤„ç†ã€‚",
            vmName, confidence,
        )
    } else if confidence >= 85 {
        return fmt.Sprintf(
            "ã€å…³æ³¨ã€‘è™šæ‹Ÿæœº '%s' å¯èƒ½æ˜¯åƒµå°¸æœºï¼ˆç½®ä¿¡åº¦ %.1f%%ï¼‰ï¼Œå»ºè®®è¿›ä¸€æ­¥ç¡®è®¤ä¸šåŠ¡ç”¨é€”ã€‚",
            vmName, confidence,
        )
    } else {
        return fmt.Sprintf(
            "ã€å¾…ç¡®è®¤ã€‘è™šæ‹Ÿæœº '%s' æœ‰åƒµå°¸æœºç‰¹å¾ï¼ˆç½®ä¿¡åº¦ %.1f%%ï¼‰ï¼Œä½†å»ºè®®äººå·¥å¤æ ¸ã€‚",
            vmName, confidence,
        )
    }
}
```

### 1.5 è¾¹ç•Œæ¡ä»¶å¤„ç†

#### 1.5.1 æ•°æ®ä¸è¶³åœºæ™¯

```go
// åœºæ™¯1ï¼šæŒ‡æ ‡æ•°æ®ä¸ºç©º
if len(cpuMetrics) == 0 {
    log.Warnf("VM %s æ²¡æœ‰CPUæ•°æ®ï¼Œè·³è¿‡åˆ†æ", vm.Name)
    continue
}

// åœºæ™¯2ï¼šæ•°æ®é‡‡æ ·ç‚¹è¿‡å°‘ï¼ˆ< 10%æœŸæœ›å€¼ï¼‰
expectedSamples := config.AnalysisDays * 24 * 3 // å‡è®¾20åˆ†é’Ÿé‡‡æ ·ä¸€æ¬¡
if len(cpuMetrics) < expectedSamples / 10 {
    log.Warnf("VM %s CPUæ•°æ®ä¸è¶³ï¼ˆ%d/%dï¼‰ï¼Œè·³è¿‡åˆ†æ", 
        vm.Name, len(cpuMetrics), expectedSamples)
    continue
}

// åœºæ™¯3ï¼šæ•°æ®è´¨é‡åˆ†æ•°è¿‡ä½
avgQuality := CalculateAvgQuality(cpuMetrics)
if avgQuality < 60 {
    log.Warnf("VM %s æ•°æ®è´¨é‡ä½ï¼ˆ%.1fåˆ†ï¼‰ï¼Œè·³è¿‡åˆ†æ", vm.Name, avgQuality)
    continue
}
```

#### 1.5.2 ç‰¹æ®ŠVMç±»å‹

```go
// æ’é™¤æ¨¡æ¿VM
if vm.IsTemplate {
    continue
}

// æ’é™¤è¿‘æœŸåˆ›å»ºçš„VM
if vm.CreatedAt != nil {
    daysSinceCreated := time.Since(*vm.CreatedAt).Hours() / 24
    if daysSinceCreated < float64(config.ExcludeRecentStarted) {
        log.Infof("VM %s åˆ›å»ºä»… %.0f å¤©ï¼Œæš‚ä¸åˆ†æ", vm.Name, daysSinceCreated)
        continue
    }
}

// æ’é™¤ç‰¹æ®Šæ ‡è®°çš„VMï¼ˆé€šè¿‡ç™½åå•æœºåˆ¶ï¼‰
if IsInWhitelist(vm.VMKey) {
    log.Infof("VM %s åœ¨ç™½åå•ä¸­ï¼Œè·³è¿‡åˆ†æ", vm.Name)
    continue
}
```

#### 1.5.3 å¼‚å¸¸å€¼å¤„ç†

```go
// è¿‡æ»¤å¼‚å¸¸é«˜çš„CPUå€¼ï¼ˆå¯èƒ½æ˜¯é‡‡é›†é”™è¯¯ï¼‰
filteredCPU := []float64{}
for _, metric := range cpuMetrics {
    // å¦‚æœCPUç™¾åˆ†æ¯”è¶…è¿‡200%ï¼Œå¯èƒ½æ˜¯æ•°æ®å¼‚å¸¸
    if metric.Percentage <= 200 {
        filteredCPU = append(filteredCPU, metric.Percentage)
    } else {
        log.Warnf("æ£€æµ‹åˆ°å¼‚å¸¸CPUå€¼: %.2f%%, å·²è¿‡æ»¤", metric.Percentage)
    }
}

// ä½¿ç”¨è¿‡æ»¤åçš„æ•°æ®è®¡ç®—
cpuMetrics = filteredCPU
```

### 1.6 æ€§èƒ½ä¼˜åŒ–

#### 1.6.1 æ‰¹é‡æŸ¥è¯¢ä¼˜åŒ–

```go
// ä¼˜åŒ–å‰ï¼šé€VMæŸ¥è¯¢æŒ‡æ ‡
for _, vm := range vms {
    metrics := repo.QueryMetrics(vm.ID, "cpu", start, end)
    // å¤„ç†...
}

// ä¼˜åŒ–åï¼šæ‰¹é‡æŸ¥è¯¢æ‰€æœ‰VMçš„æŒ‡æ ‡
vmIDs := extractVMIDs(vms)
allMetrics := repo.BatchQueryMetrics(vmIDs, []string{"cpu", "memory"}, start, end)

// æŒ‰VMåˆ†ç»„
metricsByVM := groupMetricsByVM(allMetrics)

for _, vm := range vms {
    metrics := metricsByVM[vm.ID]
    // å¤„ç†...
}
```

#### 1.6.2 å¹¶å‘å¤„ç†

```go
// ä½¿ç”¨workeræ± å¹¶å‘åˆ†æ
type AnalysisJob struct {
    VM     storage.VM
    Result *ZombieVMResult
    Error  error
}

jobs := make(chan storage.VM, len(vms))
results := make(chan *AnalysisJob, len(vms))

// å¯åŠ¨workers
workerCount := runtime.NumCPU()
var wg sync.WaitGroup

for i := 0; i < workerCount; i++ {
    wg.Add(1)
    go func() {
        defer wg.Done()
        for vm := range jobs {
            result, err := analyzeZombieVM(vm, config)
            results <- &AnalysisJob{VM: vm, Result: result, Error: err}
        }
    }()
}

// åˆ†å‘ä»»åŠ¡
for _, vm := range vms {
    jobs <- vm
}
close(jobs)

// ç­‰å¾…å®Œæˆ
go func() {
    wg.Wait()
    close(results)
}()

// æ”¶é›†ç»“æœ
finalResults := []ZombieVMResult{}
for job := range results {
    if job.Error != nil {
        log.Error(job.Error)
        continue
    }
    if job.Result != nil {
        finalResults = append(finalResults, *job.Result)
    }
}
```

---

## 2. Right Sizeè¯„ä¼°ç®—æ³•è¯¦ç»†å®æ–½

### 2.1 ç®—æ³•ç›®æ ‡

æ ¹æ®å†å²ä½¿ç”¨æƒ…å†µè¯„ä¼°VMé…ç½®æ˜¯å¦åˆç†ï¼Œæä¾›æ‰©å®¹æˆ–ç¼©å®¹å»ºè®®ï¼Œä¼˜åŒ–èµ„æºåˆ©ç”¨ç‡ã€‚

### 2.2 æ•°æ®éœ€æ±‚

| æ•°æ®ç±»å‹ | å¿…éœ€/å¯é€‰ | æ•°æ®æ ¼å¼ | ç”¨é€” |
|---------|----------|---------|------|
| VMå½“å‰é…ç½® | å¿…éœ€ | CPUæ ¸å¿ƒæ•°, å†…å­˜MB | å¯¹æ¯”åŸºå‡† |
| CPUä½¿ç”¨ç‡æ—¶åº | å¿…éœ€ | æ—¶é—´åºåˆ—ï¼ˆç»å¯¹å€¼ + ç™¾åˆ†æ¯”ï¼‰ | P95è®¡ç®— |
| å†…å­˜ä½¿ç”¨ç‡æ—¶åº | å¿…éœ€ | æ—¶é—´åºåˆ—ï¼ˆç»å¯¹å€¼ + ç™¾åˆ†æ¯”ï¼‰ | P95è®¡ç®— |
| ç£ç›˜ä½¿ç”¨ç‡ | å¯é€‰ | æ—¶é—´åºåˆ— | å­˜å‚¨å®¹é‡è¯„ä¼° |
| ä¸šåŠ¡ç±»å‹æ ‡ç­¾ | å¯é€‰ | String | å·®å¼‚åŒ–ç­–ç•¥ |

### 2.3 ç®—æ³•æµç¨‹å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Right Sizeè¯„ä¼°å®Œæ•´æµç¨‹                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

è¾“å…¥å‚æ•°:
  - connectionID: uint
  - config: *RightSizeConfig

Step 1: æ•°æ®å‡†å¤‡
â”œâ”€ 1.1 è·å–å¼€æœºçš„VMåˆ—è¡¨
â”‚  â””â”€ SELECT * FROM vms WHERE connection_id = ? AND power_state = 'poweredOn'
â”‚
â”œâ”€ 1.2 ç¡®å®šæ—¶é—´çª—å£
â”‚  â”œâ”€ endTime = now()
â”‚  â””â”€ startTime = now() - config.AnalysisDays
â”‚
â””â”€ 1.3 ç¡®å®šæ•°æ®ç²’åº¦
   â”œâ”€ IF AnalysisDays <= 7: ä½¿ç”¨åˆ†é’Ÿçº§æ•°æ®
   â”œâ”€ ELSE IF AnalysisDays <= 30: ä½¿ç”¨å°æ—¶çº§æ•°æ®
   â””â”€ ELSE: ä½¿ç”¨å¤©çº§æ•°æ®

Step 2: é€VMåˆ†æ
FOR EACH vm IN vms:
    
    2.1 è·å–æŒ‡æ ‡æ•°æ®
    â”œâ”€ cpuMetrics = QueryMetrics(vm.ID, "cpu", startTime, endTime, granularity)
    â””â”€ memMetrics = QueryMetrics(vm.ID, "memory", startTime, endTime, granularity)
    
    2.2 æ•°æ®å®Œæ•´æ€§æ£€æŸ¥
    IF len(cpuMetrics) < MinSampleThreshold:
        SKIP (æ•°æ®ä¸è¶³)
    
    2.3 æå–ç™¾åˆ†æ¯”æ•°æ®
    â”œâ”€ cpuPercentages = Extract(cpuMetrics, "percentage")
    â””â”€ memPercentages = Extract(memMetrics, "percentage")
    
    2.4 è®¡ç®—ç»Ÿè®¡å€¼
    â”œâ”€ cpuP95 = Percentile(cpuPercentages, config.Percentile)
    â”œâ”€ cpuPeak = Max(cpuPercentages)
    â”œâ”€ cpuAvg = Average(cpuPercentages)
    â”œâ”€ memP95 = Percentile(memPercentages, config.Percentile)
    â”œâ”€ memPeak = Max(memPercentages)
    â””â”€ memAvg = Average(memPercentages)
    
    2.5 è®¡ç®—æ¨èé…ç½®
    â”œâ”€ åŸºäºP95å€¼å’Œç¼“å†²æ¯”ä¾‹
    â”‚  â”œâ”€ recCPU = Ceiling((cpuP95 / 100) * vm.CPUCount * config.BufferRatio)
    â”‚  â””â”€ recMem = Ceiling((memP95 / 100) * vm.MemoryMB * config.BufferRatio)
    â”‚
    â”œâ”€ åº”ç”¨æœ€å°å€¼é™åˆ¶
    â”‚  â”œâ”€ recCPU = Max(recCPU, config.MinCPU)
    â”‚  â””â”€ recMem = Max(recMem, config.MinMemoryMB)
    â”‚
    â””â”€ åº”ç”¨è°ƒæ•´ç²’åº¦
       â”œâ”€ IF granularity == "strict_integer": å››èˆäº”å…¥åˆ°æ•´æ•°
       â”œâ”€ ELSE IF granularity == "integer_preferred": ä¼˜å…ˆæ•´æ•°ï¼Œå…è®¸.5
       â””â”€ ELSE: ä¿æŒç²¾ç¡®è®¡ç®—å€¼
    
    2.6 åˆ¤å®šè°ƒæ•´ç±»å‹
    cpuChange = (recCPU - vm.CPUCount) / vm.CPUCount
    memChange = (recMem - vm.MemoryMB) / vm.MemoryMB
    maxChange = Max(abs(cpuChange), abs(memChange))
    
    adjustmentType = DetermineAdjustmentType(cpuChange, memChange, maxChange, config)
    
    2.7 è¯„ä¼°é£é™©
    â”œâ”€ è®¡ç®—æ³¢åŠ¨ç‡ (æ ‡å‡†å·®/å‡å€¼)
    â”œâ”€ æ£€æŸ¥å³°å€¼ä¸P95çš„å·®è·
    â””â”€ è¯„ä¼°æ•°æ®å®Œæ•´æ€§
    
    riskLevel = AssessRisk(cpuPercentages, memPercentages, vm, config)
    
    2.8 è®¡ç®—èŠ‚çœä¼°ç®—
    savings = CalculateSavings(vm.CPUCount, recCPU, vm.MemoryMB, recMem)
    
    2.9 è®¡ç®—ç½®ä¿¡åº¦
    confidence = CalculateConfidence(len(cpuMetrics), len(memMetrics), config.AnalysisDays)
    
    2.10 æ·»åŠ åˆ°ç»“æœ
    results.append(RightSizeResult{...})

Step 3: ç»“æœæ’åº
â”œâ”€ æŒ‰èŠ‚çœé‡é™åºæ’åºï¼ˆç¼©å®¹åœºæ™¯ï¼‰
â””â”€ æˆ–æŒ‰é£é™©ç­‰çº§æ’åºï¼ˆæ‰©å®¹åœºæ™¯ï¼‰

Step 4: è¿”å›ç»“æœ
RETURN results
```

### 2.4 å…³é”®å‡½æ•°è¯¦ç»†å®ç°

#### 2.4.1 ç™¾åˆ†ä½æ•°è®¡ç®—ï¼ˆP95/P90/P85ï¼‰

```go
// Percentile è®¡ç®—ç™¾åˆ†ä½æ•°
//
// ä½¿ç”¨çº¿æ€§æ’å€¼æ³•è®¡ç®—ç²¾ç¡®çš„ç™¾åˆ†ä½æ•°
//
// ç®—æ³•æ­¥éª¤ï¼š
// 1. æ’åºæ•°æ®
// 2. è®¡ç®—ç´¢å¼•ä½ç½® index = (p/100) * (n-1)
// 3. å¦‚æœindexæ˜¯æ•´æ•°ï¼Œç›´æ¥è¿”å›è¯¥ä½ç½®çš„å€¼
// 4. å¦‚æœindexæ˜¯å°æ•°ï¼Œåœ¨ç›¸é‚»ä¸¤ä¸ªå€¼ä¹‹é—´çº¿æ€§æ’å€¼
//
// å‚æ•°:
//   - values: æ•°æ®æ•°ç»„
//   - p: ç™¾åˆ†ä½ (0-100)
//
// è¿”å›:
//   - ç™¾åˆ†ä½æ•°å€¼
//
func Percentile(values []float64, p float64) float64 {
    if len(values) == 0 {
        return 0
    }
    
    // å¤åˆ¶å¹¶æ’åº
    sorted := make([]float64, len(values))
    copy(sorted, values)
    sort.Float64s(sorted)
    
    n := len(sorted)
    
    // è®¡ç®—ç´¢å¼•
    index := (p / 100.0) * float64(n-1)
    
    // ä¸‹ç•Œå’Œä¸Šç•Œç´¢å¼•
    lower := int(math.Floor(index))
    upper := int(math.Ceil(index))
    
    // å¦‚æœæ˜¯æ•´æ•°ç´¢å¼•ï¼Œç›´æ¥è¿”å›
    if lower == upper {
        return sorted[lower]
    }
    
    // çº¿æ€§æ’å€¼
    weight := index - float64(lower)
    return sorted[lower]*(1-weight) + sorted[upper]*weight
}

// ç¤ºä¾‹ï¼š
// values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
// P95 = Percentile(values, 95)
//     = æ’åºåç¬¬ 0.95 * 9 = 8.55 ä½ç½®
//     = 9 * 0.45 + 10 * 0.55 = 9.55
```

#### 2.4.2 æ¨èé…ç½®è®¡ç®—

```go
// CalculateRecommendedConfig è®¡ç®—æ¨èé…ç½®
//
// æ ¸å¿ƒå…¬å¼ï¼š
//   æ¨èå€¼ = å½“å‰é…ç½® Ã— (På€¼ä½¿ç”¨ç‡ / 100) Ã— ç¼“å†²æ¯”ä¾‹
//
// ç¤ºä¾‹ï¼š
//   å½“å‰: 4æ ¸, P95ä½¿ç”¨ç‡: 60%, ç¼“å†²: 1.2å€
//   æ¨è = 4 Ã— (60/100) Ã— 1.2 = 2.88 â‰ˆ 3æ ¸
//
func CalculateRecommendedCPU(
    currentCPU int32,
    p95Usage float64,
    bufferRatio float64,
    minCPU int,
    granularity string,
) int32 {
    
    // åŸºç¡€è®¡ç®—
    rawRecommended := float64(currentCPU) * (p95Usage / 100.0) * bufferRatio
    
    // åº”ç”¨æœ€å°å€¼
    if rawRecommended < float64(minCPU) {
        rawRecommended = float64(minCPU)
    }
    
    // åº”ç”¨ç²’åº¦è§„åˆ™
    var recommended int32
    switch granularity {
    case "strict_integer":
        // ä¸¥æ ¼æ•´æ•°ï¼šå››èˆäº”å…¥
        recommended = int32(math.Round(rawRecommended))
        
    case "integer_preferred":
        // æ•´æ•°ä¼˜å…ˆï¼šå…è®¸.5
        // ä¾‹å¦‚ï¼š2.3 â†’ 2, 2.5 â†’ 2.5, 2.8 â†’ 3
        if math.Abs(rawRecommended - math.Round(rawRecommended)) < 0.3 {
            recommended = int32(math.Round(rawRecommended))
        } else {
            // ä¿ç•™åˆ°0.5
            recommended = int32(math.Floor(rawRecommended*2)) / 2
        }
        
    case "precise":
        // ç²¾ç¡®è®¡ç®—ï¼šä¿æŒå°æ•°ï¼ˆä½†CPUé€šå¸¸ä¸æ”¯æŒå°æ•°ï¼Œæœ€ç»ˆè¿˜æ˜¯å–æ•´ï¼‰
        recommended = int32(math.Ceil(rawRecommended))
        
    default:
        recommended = int32(math.Ceil(rawRecommended))
    }
    
    return recommended
}

// CalculateRecommendedMemory è®¡ç®—æ¨èå†…å­˜ï¼ˆç±»ä¼¼é€»è¾‘ï¼‰ func CalculateRecommendedMemory(
    currentMemMB int32,
    p95Usage float64,
    bufferRatio float64,
    minMemMB int,
    granularity string,
) int32 {
    
    rawRecommended := float64(currentMemMB) * (p95Usage / 100.0) * bufferRatio
    
    if rawRecommended < float64(minMemMB) {
        rawRecommended = float64(minMemMB)
    }
    
    var recommended int32
    switch granularity {
    case "strict_integer":
        // å†…å­˜é€šå¸¸æŒ‰256MBæˆ–512MBå¯¹é½
        alignMB := 512
        recommended = int32(math.Round(rawRecommended/float64(alignMB))) * int32(alignMB)
        
    case "integer_preferred":
        // æŒ‰1GBå¯¹é½
        alignMB := 1024
        recommended = int32(math.Ceil(rawRecommended/float64(alignMB))) * int32(alignMB)
        
    case "precise":
        // æŒ‰å®é™…éœ€æ±‚
        recommended = int32(math.Ceil(rawRecommended))
        
    default:
        recommended = int32(math.Ceil(rawRecommended))
    }
    
    return recommended
}
```

#### 2.4.3 è°ƒæ•´ç±»å‹åˆ¤å®š

```go
// DetermineAdjustmentType åˆ¤å®šè°ƒæ•´ç±»å‹
//
// è°ƒæ•´ç±»å‹åˆ†ç±»ï¼š
//   - "å¤§å¹…ç¼©å®¹": å‡å°‘ > 30%
//   - "å°å¹…ç¼©å®¹": å‡å°‘ 15-30%
//   - "ä¿æŒ": å˜åŒ– < 15%
//   - "å°å¹…æ‰©å®¹": å¢åŠ  15-30%
//   - "å¤§å¹…æ‰©å®¹": å¢åŠ  > 30%
//
func DetermineAdjustmentType(
    cpuChange, memChange, maxChange float64,
    config *RightSizeConfig,
) string {
    
    // ä½¿ç”¨æ›´å¤§çš„å˜åŒ–å¹…åº¦ä½œä¸ºåˆ¤å®šä¾æ®
    change := maxChange
    
    if change > config.LargeMargin {
        if cpuChange > 0 || memChange > 0 {
            return "å¤§å¹…æ‰©å®¹"
        } else {
            return "å¤§å¹…ç¼©å®¹"
        }
    } else if change > config.SmallMargin {
        if cpuChange > 0 || memChange > 0 {
            return "å°å¹…æ‰©å®¹"
        } else {
            return "å°å¹…ç¼©å®¹"
        }
    } else {
        return "ä¿æŒå½“å‰é…ç½®"
    }
}
```

#### 2.4.4 é£é™©è¯„ä¼°

```go
// AssessRisk è¯„ä¼°è°ƒæ•´é£é™©
//
// é£é™©å› ç´ ï¼š
// 1. æ•°æ®æ³¢åŠ¨ç‡é«˜ â†’ é«˜é£é™©
// 2. å³°å€¼è¿œè¶…P95 â†’ ä¸­é£é™©
// 3. æ•°æ®æ ·æœ¬å°‘ â†’ ä¸­é£é™©
// 4. æ¨èå€¼æ¥è¿‘å³°å€¼ â†’ é«˜é£é™©
//
func AssessRisk(
    cpuValues, memValues []float64,
    currentCPU, recommendedCPU int32,
    currentMem, recommendedMem int32,
    config *RightSizeConfig,
) string {
    
    riskScore := 0
    
    // 1. è®¡ç®—CPUæ³¢åŠ¨ç‡ï¼ˆå˜å¼‚ç³»æ•° CV = æ ‡å‡†å·®/å‡å€¼ï¼‰
    cpuCV := CoefficientOfVariation(cpuValues)
    if cpuCV > config.RiskThreshold/100 {
        riskScore += 2  // æ³¢åŠ¨å¤§ï¼Œé£é™©é«˜
    } else if cpuCV > (config.RiskThreshold/100)*0.7 {
        riskScore += 1
    }
    
    // 2. è®¡ç®—å†…å­˜æ³¢åŠ¨ç‡
    memCV := CoefficientOfVariation(memValues)
    if memCV > config.RiskThreshold/100 {
        riskScore += 2
    } else if memCV > (config.RiskThreshold/100)*0.7 {
        riskScore += 1
    }
    
    // 3. æ£€æŸ¥å³°å€¼ä¸P95çš„å·®è·
    cpuP95 := Percentile(cpuValues, float64(config.Percentile))
    cpuPeak := Max(cpuValues)
    if cpuPeak - cpuP95 > 20 { // å³°å€¼æ¯”P95é«˜20%ä»¥ä¸Š
        riskScore += 1
    }
    
    // 4. æ£€æŸ¥æ¨èé…ç½®æ˜¯å¦æ¥è¿‘å³°å€¼ä½¿ç”¨
    if recommendedCPU < currentCPU { // ç¼©å®¹åœºæ™¯
        // æ¨èå€¼è¦èƒ½å®¹çº³å³°å€¼
        peakCPUNeeded := (cpuPeak / 100) * float64(currentCPU)
        recCPUCapacity := float64(recommendedCPU)
        
        if recCPUCapacity < peakCPUNeeded * 1.1 { // æ¨èå€¼ä¸è¶³å³°å€¼+10%
            riskScore += 2
        }
    }
    
    // 5. æ•°æ®æ ·æœ¬å……è¶³æ€§
    if len(cpuValues) < config.AnalysisDays * 24 / 2 { // æ ·æœ¬æ•°< æœŸæœ›çš„50%
        riskScore += 1
    }
    
    // ç»¼åˆåˆ¤å®š
    if riskScore >= 4 {
        return "é«˜é£é™©"
    } else if riskScore >= 2 {
        return "ä¸­é£é™©"
    } else {
        return "ä½é£é™©"
    }
}

// CoefficientOfVariation è®¡ç®—å˜å¼‚ç³»æ•°
func CoefficientOfVariation(values []float64) float64 {
    if len(values) == 0 {
        return 0
    }
    
    mean := Average(values)
    if mean == 0 {
        return 0
    }
    
    variance := 0.0
    for _, v := range values {
        diff := v - mean
        variance += diff * diff
    }
    variance /= float64(len(values))
    
    stdDev := math.Sqrt(variance)
    cv := stdDev / mean
    
    return cv
}
```

#### 2.4.5 èŠ‚çœä¼°ç®—

```go
// CalculateSavings è®¡ç®—èŠ‚çœä¼°ç®—
//
// è®¡ç®—é€»è¾‘ï¼š
//   èŠ‚çœé‡ = (å½“å‰é…ç½® - æ¨èé…ç½®) / å½“å‰é…ç½® Ã— 100%
//   èŠ‚çœæˆæœ¬ = èŠ‚çœçš„èµ„æº Ã— å•ä»·ï¼ˆå¦‚æœæœ‰ï¼‰
//
func CalculateSavings(
    currentCPU, recommendedCPU int32,
    currentMem, recommendedMem int32,
) string {
    
    cpuSaving := float64(currentCPU - recommendedCPU)
    memSavingMB := float64(currentMem - recommendedMem)
    memSavingGB := memSavingMB / 1024
    
    cpuSavingPercent := (cpuSaving / float64(currentCPU)) * 100
    memSavingPercent := (memSavingGB * 1024 / float64(currentMem)) * 100
    
    if cpuSaving < 0 && memSavingMB < 0 {
        // æ‰©å®¹åœºæ™¯
        return fmt.Sprintf(
            "éœ€è¦å¢åŠ  %d æ ¸ CPU (%.1f%%) å’Œ %.1f GB å†…å­˜ (%.1f%%)",
            -int32(cpuSaving),
            -cpuSavingPercent,
            -memSavingGB,
            -memSavingPercent,
        )
    } else if cpuSaving > 0 || memSavingMB > 0 {
        // ç¼©å®¹åœºæ™¯
        msg := "å¯èŠ‚çœ "
        if cpuSaving > 0 {
            msg += fmt.Sprintf("%d æ ¸ CPU (%.1f%%)", int32(cpuSaving), cpuSavingPercent)
        }
        if memSavingMB > 0 {
            if cpuSaving > 0 {
                msg += " å’Œ "
            }
            msg += fmt.Sprintf("%.1f GB å†…å­˜ (%.1f%%)", memSavingGB, memSavingPercent)
        }
        return msg
    } else {
        return "é…ç½®åˆç†ï¼Œæ— éœ€è°ƒæ•´"
    }
}
```

### 2.5 ç‰¹æ®Šåœºæ™¯å¤„ç†

#### 2.5.1 ä¸šåŠ¡ç±»å‹å·®å¼‚åŒ–ç­–ç•¥

```go
// ApplyBusinessTypeStrategy æ ¹æ®ä¸šåŠ¡ç±»å‹è°ƒæ•´ç­–ç•¥
//
// ä¸åŒä¸šåŠ¡ç±»å‹æœ‰ä¸åŒçš„é£é™©æ‰¿å—èƒ½åŠ›
//
func ApplyBusinessTypeStrategy(
    vm *storage.VM,
    baseConfig *RightSizeConfig,
) *RightSizeConfig {
    
    config := *baseConfig // å¤åˆ¶
    
    // æ ¹æ®VMæ ‡ç­¾æˆ–åç§°åˆ¤æ–­ä¸šåŠ¡ç±»å‹
    businessType := IdentifyBusinessType(vm)
    
    switch businessType {
    case "database":
        // æ•°æ®åº“ï¼šæ›´ä¿å®ˆçš„ç­–ç•¥
        config.BufferRatio = math.Max(config.BufferRatio, 1.30)
        config.Percentile = 95 // å¼ºåˆ¶ä½¿ç”¨P95
        config.RiskThreshold = 25.0
        
    case "web_server":
        // WebæœåŠ¡å™¨ï¼šå¯ä»¥é€‚å½“æ¿€è¿›
        config.BufferRatio = 1.15
        config.Percentile = 90
        
    case "batch_job":
        // æ‰¹å¤„ç†ä»»åŠ¡ï¼šå¯ä»¥æ›´æ¿€è¿›
        config.BufferRatio = 1.10
        config.Percentile = 85
        
    case "dev_test":
        // å¼€å‘æµ‹è¯•ç¯å¢ƒï¼šéå¸¸æ¿€è¿›
        config.BufferRatio = 1.05
        config.MinCPU = 1
        config.MinMemoryMB = 512
        
    default:
        // æœªçŸ¥ç±»å‹ï¼šä½¿ç”¨åŸºç¡€é…ç½®
    }
    
    return &config
}
```

---

## 3. æ½®æ±æ¨¡å¼æ£€æµ‹ç®—æ³•ï¼ˆç®€è¦ï¼‰

### 3.1 æ ¸å¿ƒæ­¥éª¤

1. **æ•°æ®åˆ†ç»„**ï¼šæŒ‰å°æ—¶/æŒ‰æ˜ŸæœŸåˆ†ç»„
2. **è®¡ç®—æ–¹å·®**ï¼šæ£€æµ‹å‘¨æœŸæ€§æ³¢åŠ¨
3. **æ¨¡å¼è¯†åˆ«**ï¼šåˆ¤å®šæ—¥å‘¨æœŸæˆ–å‘¨å‘¨æœŸ
4. **ç¨³å®šæ€§è¯„åˆ†**ï¼šè¯„ä¼°æ¨¡å¼å¯é æ€§
5. **å³°è°·è¯†åˆ«**ï¼šç¡®å®šå¯åœæ—¶æ®µ

ï¼ˆè¯¦ç»†å®ç°è§ç‹¬ç«‹æ–‡æ¡£ï¼‰

---

## 4. å¥åº·è¯„åˆ†ç®—æ³•ï¼ˆç®€è¦ï¼‰

### 4.1 æ ¸å¿ƒç»´åº¦

1. **èµ„æºå‡è¡¡åº¦**ï¼šä¸»æœºé—´VMåˆ†å¸ƒçš„æ ‡å‡†å·®
2. **è¶…é…é£é™©**ï¼šèµ„æºè¶…é…æ¯”ä¾‹
3. **çƒ­ç‚¹é›†ä¸­åº¦**ï¼šé«˜è´Ÿè½½ä¸»æœºå æ¯”

ï¼ˆè¯¦ç»†å®ç°è§ç‹¬ç«‹æ–‡æ¡£ï¼‰

---

## 5. é€šç”¨å·¥å…·å‡½æ•°

```go
// ç»Ÿè®¡å‡½æ•°åº“

func Average(values []float64) float64 {
    if len(values) == 0 {
        return 0
    }
    sum := 0.0
    for _, v := range values {
        sum += v
    }
    return sum / float64(len(values))
}

func Max(values []float64) float64 {
    if len(values) == 0 {
        return 0
    }
    max := values[0]
    for _, v := range values[1:] {
        if v > max {
            max = v
        }
    }
    return max
}

func Min(values []float64) float64 {
    if len(values) == 0 {
        return 0
    }
    min := values[0]
    for _, v := range values[1:] {
        if v < min {
            min = v
        }
    }
    return min
}

func StandardDeviation(values []float64) float64 {
    if len(values) == 0 {
        return 0
    }
    
    avg := Average(values)
    variance := 0.0
    for _, v := range values {
        diff := v - avg
        variance += diff * diff
    }
    variance /= float64(len(values))
    
    return math.Sqrt(variance)
}
```

---

## 6. æµ‹è¯•ç­–ç•¥

### 6.1 å•å…ƒæµ‹è¯•

```go
// æµ‹è¯•ç™¾åˆ†ä½æ•°è®¡ç®—
func TestPercentile(t *testing.T) {
    values := []float64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    
    assert.Equal(t, 5.5, Percentile(values, 50))  // P50 (ä¸­ä½æ•°)
    assert.Equal(t, 9.5, Percentile(values, 95))  // P95
    assert.Equal(t, 10.0, Percentile(values, 100)) // P100 (æœ€å¤§å€¼)
}

// æµ‹è¯•ç½®ä¿¡åº¦è®¡ç®—
func TestCalculateConfidence(t *testing.T) {
    // æä½ä½¿ç”¨ç‡ï¼Œåº”è¯¥é«˜ç½®ä¿¡åº¦
    confidence := CalculateConfidence(1.0, 3.0, 2.0, 10.0, 14, 14, DefaultConfig())
    assert.True(t, confidence >= 90)
    
    // è¾¹ç•Œå€¼ï¼Œåº”è¯¥ä¸­ç­‰ç½®ä¿¡åº¦
    confidence = CalculateConfidence(5.0, 10.0, 10.0, 100.0, 10, 14, DefaultConfig())
    assert.True(t, confidence >= 75 && confidence < 90)
}
```

### 6.2 é›†æˆæµ‹è¯•

æ¨¡æ‹ŸçœŸå®æ•°æ®åœºæ™¯ï¼ŒéªŒè¯ç«¯åˆ°ç«¯æµç¨‹ã€‚

---

## 7. æ€»ç»“

æœ¬æ‰‹å†Œæä¾›äº†åƒµå°¸VMæ£€æµ‹å’ŒRight Sizeè¯„ä¼°ç®—æ³•çš„å®Œæ•´å®æ–½ç»†èŠ‚ï¼ŒåŒ…æ‹¬ï¼š

1. âœ… å®Œæ•´çš„ç®—æ³•æµç¨‹å›¾
2. âœ… å…³é”®å‡½æ•°çš„ä¼ªä»£ç å’Œè¯´æ˜
3. âœ… è¾¹ç•Œæ¡ä»¶å’Œå¼‚å¸¸å¤„ç†
4. âœ… æ€§èƒ½ä¼˜åŒ–å»ºè®®
5. âœ… æµ‹è¯•ç­–ç•¥

**åç»­æ‰©å±•**ï¼šæ½®æ±æ£€æµ‹å’Œå¥åº·è¯„åˆ†çš„è¯¦ç»†å®æ–½å°†åœ¨ä¸“é—¨æ–‡æ¡£ä¸­è¡¥å……ã€‚

