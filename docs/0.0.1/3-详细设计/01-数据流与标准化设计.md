# JustFit 数据流与标准化设计文档

## 0. 文档信息

| 项目 | 内容 |
|------|------|
| 文档名称 | 数据流与标准化设计文档 |
| 版本 | v1.0 |
| 日期 | 2026-02-08 |
| 项目版本 | v0.0.1 Beta |
| 状态 | 已确认 |

## 1. 数据流架构总览

### 1.1 端到端数据流

```
┌────────────────────────────────────────────────────────────────────────┐
│                          数据采集层 (Connector Layer)                   │
├────────────────────────────────────────────────────────────────────────┤
│                                                                        │
│  ┌──────────────────────┐              ┌──────────────────────┐      │
│  │   vCenter Connector  │              │    UIS Connector     │      │
│  ├──────────────────────┤              ├──────────────────────┤      │
│  │ govmomi SDK          │              │ HTTP REST API        │      │
│  │                      │              │                      │      │
│  │ 采集数据：            │              │ 采集数据：            │      │
│  │ - 基本信息           │              │ - 基本信息           │      │
│  │ - 配置信息           │              │ - 配置信息           │      │
│  │ - 性能指标 (原始)    │              │ - 性能指标 (报表)    │      │
│  │                      │              │                      │      │
│  │ 数据格式：            │              │ 数据格式：            │      │
│  │ - CPU: MHz (绝对值)  │              │ - CPU: % (百分比)    │      │
│  │ - Memory: Bytes      │              │ - Memory: %          │      │
│  │ - Disk: IOPS         │              │ - Disk: IOPS/MB      │      │
│  │ - Network: KB/s      │              │ - Network: KB/s      │      │
│  │                      │              │                      │      │
│  │ 数据粒度：            │              │ 数据粒度：            │      │
│  │ - 7天内: 分钟级      │              │ - 30天内: 小时级     │      │
│  │ - 30天内: 小时级     │              │ - 返回: 最小/最大/均值│      │
│  │ - 1年内: 天级        │              │                      │      │
│  └──────────────────────┘              └──────────────────────┘      │
│            │                                      │                  │
│            └──────────────────┬───────────────────┘                  │
└───────────────────────────────┼──────────────────────────────────────┘
                                ▼
┌────────────────────────────────────────────────────────────────────────┐
│                      数据治理层 (ETL Layer)                             │
├────────────────────────────────────────────────────────────────────────┤
│                                                                        │
│  ┌────────────────────────────────────────────────────────────────┐   │
│  │                  Extract (提取) - 原始数据接收                   │   │
│  ├────────────────────────────────────────────────────────────────┤   │
│  │  • 接收 Connector 返回的多源数据                                │   │
│  │  • 验证数据完整性（必填字段、时间戳、数据类型）                  │   │
│  │  • 识别数据来源平台（vCenter/UIS）                              │   │
│  └────────────────────────────────────────────────────────────────┘   │
│                                ▼                                       │
│  ┌────────────────────────────────────────────────────────────────┐   │
│  │                  Transform (转换) - 数据标准化                   │   │
│  ├────────────────────────────────────────────────────────────────┤   │
│  │                                                                 │   │
│  │  Step 1: 单位归一化                                             │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │ vCenter:                    │  UIS:                      │   │   │
│  │  │ CPU MHz → Cores (MHz/CpuMhz)│  CPU % → 保持 %            │   │   │
│  │  │ Memory Bytes → MB           │  Memory % → 保持 %         │   │   │
│  │  │ Disk IOPS → IOPS            │  Disk IOPS → IOPS          │   │   │
│  │  │ Network KB/s → KB/s         │  Network KB/s → KB/s       │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │                                                                 │   │
│  │  Step 2: 计算双格式数据                                         │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │ 对于每个指标，计算并存储：                               │   │   │
│  │  │                                                          │   │   │
│  │  │ ① 绝对值 (absolute_value)                               │   │   │
│  │  │    - CPU: Cores (实际使用核心数)                        │   │   │
│  │  │    - Memory: MB (实际使用内存)                          │   │   │
│  │  │    - Disk: IOPS (每秒IO操作数)                          │   │   │
│  │  │    - Network: KB/s (网络吞吐量)                         │   │   │
│  │  │                                                          │   │   │
│  │  │ ② 百分比 (percentage_value)                             │   │   │
│  │  │    - CPU %: (使用Cores / 配置Cores) × 100              │   │   │
│  │  │    - Memory %: (使用MB / 配置MB) × 100                 │   │   │
│  │  │    - Disk %: 基于IOPS上限计算（如果有）                 │   │   │
│  │  │    - Network %: 基于带宽上限计算（如果有）              │   │   │
│  │  │                                                          │   │   │
│  │  │ 转换公式：                                               │   │   │
│  │  │   - vCenter: 绝对值已知 → 计算百分比                    │   │   │
│  │  │   - UIS: 百分比已知 + 配置信息 → 计算绝对值             │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │                                                                 │   │
│  │  Step 3: 时间聚合（根据查询窗口）                               │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │ 分钟级数据 (< 7天):                                      │   │   │
│  │  │   → 直接存储原始数据点                                   │   │   │
│  │  │                                                          │   │   │
│  │  │ 小时级数据 (7-30天):                                     │   │   │
│  │  │   → 每小时聚合：min, max, avg, p50, p95                │   │   │
│  │  │   → 记录样本数量                                         │   │   │
│  │  │                                                          │   │   │
│  │  │ 天级数据 (> 30天):                                       │   │   │
│  │  │   → 每天聚合：min, max, avg, p95                        │   │   │
│  │  │   → 记录样本数量                                         │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │                                                                 │   │
│  │  Step 4: 数据质量标记                                           │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │ • 标记异常值（超出合理范围）                             │   │   │
│  │  │ • 标记缺失数据（时间序列中的空缺）                       │   │   │
│  │  │ • 计算数据置信度（基于样本数量和完整性）                 │   │   │
│  │  │ • 记录数据来源和处理时间                                 │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │                                                                 │   │
│  └────────────────────────────────────────────────────────────────┘   │
│                                ▼                                       │
│  ┌────────────────────────────────────────────────────────────────┐   │
│  │                   Load (加载) - 持久化存储                       │   │
│  ├────────────────────────────────────────────────────────────────┤   │
│  │  • 批量插入数据库（SQLite）                                     │   │
│  │  • 更新元数据索引                                               │   │
│  │  • 记录 ETL 日志                                                │   │
│  └────────────────────────────────────────────────────────────────┘   │
│                                                                        │
└────────────────────────────────────────────────────────────────────────┘
                                ▼
┌────────────────────────────────────────────────────────────────────────┐
│                       存储层 (Storage Layer)                            │
├────────────────────────────────────────────────────────────────────────┤
│                                                                        │
│  ┌──────────────────────────────────────────────────────────────┐     │
│  │  metrics 表 (性能指标 - 双格式存储)                          │     │
│  ├──────────────────────────────────────────────────────────────┤     │
│  │  • vm_id           - 虚拟机ID (外键)                         │     │
│  │  • metric_type     - 指标类型 (cpu, memory, disk, network)  │     │
│  │  • timestamp       - 时间戳                                  │     │
│  │  • absolute_value  - 绝对值 (Cores/MB/IOPS/KB/s)            │     │
│  │  • percentage      - 百分比 (%)                              │     │
│  │  • granularity     - 数据粒度 (minute/hour/day)             │     │
│  │  • source_platform - 数据来源 (vcenter/uis)                 │     │
│  │  • quality_score   - 数据质量分数 (0-100)                   │     │
│  │  • created_at      - 创建时间                                │     │
│  │                                                              │     │
│  │  索引:                                                        │     │
│  │  - (vm_id, metric_type, timestamp)                          │     │
│  │  - (vm_id, metric_type, granularity, timestamp)             │     │
│  └──────────────────────────────────────────────────────────────┘     │
│                                                                        │
│  ┌──────────────────────────────────────────────────────────────┐     │
│  │  vms 表 (虚拟机配置信息 - 用于百分比转换)                     │     │
│  ├──────────────────────────────────────────────────────────────┤     │
│  │  • id               - 主键                                   │     │
│  │  • vm_key           - 虚拟机唯一标识                         │     │
│  │  • name             - 虚拟机名称                             │     │
│  │  • cpu_count        - 配置的CPU核心数                        │     │
│  │  • memory_mb        - 配置的内存(MB)                         │     │
│  │  • disk_size_gb     - 配置的磁盘大小(GB)                     │     │
│  │  • network_limit_kb - 网络带宽限制(KB/s) - 可选              │     │
│  │  • power_state      - 电源状态                               │     │
│  │  • collected_at     - 采集时间                               │     │
│  └──────────────────────────────────────────────────────────────┘     │
│                                                                        │
└────────────────────────────────────────────────────────────────────────┘
                                ▼
┌────────────────────────────────────────────────────────────────────────┐
│                        分析层 (Analyzer Layer)                         │
├────────────────────────────────────────────────────────────────────────┤
│                                                                        │
│  算法可以灵活选择使用：                                                │
│  • 绝对值数据（适合跨平台比较、资源总量统计）                          │
│  • 百分比数据（适合利用率分析、阈值比较）                              │
│  • 两者结合（提供更全面的分析依据）                                   │
│                                                                        │
│  所有算法支持：                                                        │
│  • 自动选择合适的数据粒度（分钟/小时/天）                              │
│  • 灵活配置分析窗口（7天/30天/1年等）                                 │
│  • 多模式运行（安全/节省/激进/自定义）                                 │
│                                                                        │
└────────────────────────────────────────────────────────────────────────┘
```

## 2. 数据采集层详细设计

### 2.1 vCenter 数据采集

#### 2.1.1 采集能力矩阵

| 数据类型 | API来源 | 数据格式 | 数据粒度 | 历史范围 |
|---------|---------|----------|----------|---------|
| VM基本信息 | PropertyCollector | 快照数据 | 实时 | 当前状态 |
| VM配置信息 | VM.Config | 快照数据 | 实时 | 当前状态 |
| CPU指标 | PerformanceManager | MH时间序列 | 分钟/小时/天 | 7天/30天/1年 |
| 内存指标 | PerformanceManager | Bytes时间序列 | 分钟/小时/天 | 7天/30天/1年 |
| 磁盘IO | PerformanceManager | IOPS时间序列 | 分钟/小时/天 | 7天/30天/1年 |
| 网络流量 | PerformanceManager | KB/s时间序列 | 分钟/小时/天 | 7天/30天/1年 |

#### 2.1.2 采集实现代码框架

```go
// vCenter 性能指标采集
func (vc *VCenterClient) GetVMMetrics(
    vmRef types.ManagedObjectReference,
    metricNames []string,  // ["cpu.usage.average", "mem.usage.average"]
    startTime, endTime time.Time,
    intervalSec int,       // 20, 300, 3600 (分钟/小时)
) (*VMMetricsResult, error) {
    
    perfManager := performance.NewManager(vc.client.Client)
    
    // 构建查询规格
    spec := types.PerfQuerySpec{
        Entity:     vmRef,
        StartTime:  &startTime,
        EndTime:    &endTime,
        IntervalId: int32(intervalSec),
        Format:     string(types.PerfFormatNormal),
    }
    
    // 查询性能数据
    result, err := perfManager.QueryPerf(vc.ctx, []types.PerfQuerySpec{spec})
    if err != nil {
        return nil, err
    }
    
    // 解析并返回标准格式
    return parseVCenterMetrics(result), nil
}

// 解析为标准格式（绝对值）
func parseVCenterMetrics(raw *types.PerfEntityMetric) *VMMetricsResult {
    metrics := &VMMetricsResult{
        SourcePlatform: "vcenter",
        DataPoints: []MetricDataPoint{},
    }
    
    for _, series := range raw.Value {
        metricName := series.Name // e.g., "cpu.usage.average"
        
        for i, timestamp := range raw.SampleInfo {
            dataPoint := MetricDataPoint{
                Timestamp: timestamp,
                MetricType: parseMetricType(metricName),
                AbsoluteValue: series.Value[i], // CPU: MHz, Memory: Bytes
                SourcePlatform: "vcenter",
            }
            metrics.DataPoints = append(metrics.DataPoints, dataPoint)
        }
    }
    
    return metrics
}
```

### 2.2 UIS 数据采集

#### 2.2.1 采集能力矩阵

| 数据类型 | API端点 | 返回格式 | 数据粒度 | 历史范围 |
|---------|---------|----------|----------|---------|
| VM基本信息 | /uis/uis/vm/list | JSON | 实时 | 当前状态 |
| CPU利用率 | /uis/uis/report/cpuMemVm?type=0 | % (min/avg/max) | 小时 | 30天 |
| 内存利用率 | /uis/uis/report/cpuMemVm?type=1 | % (min/avg/max) | 小时 | 30天 |
| 磁盘读写 | /uis/uis/report/diskVm | IOPS/MB/s | 小时 | 30天 |
| 网络流量 | /uis/uis/report/netSpVm | KB/s (min/avg/max) | 小时 | 30天 |

#### 2.2.2 采集实现代码框架

```go
// UIS 性能指标采集
func (uis *UISConnector) GetVMMetrics(
    vmID int,
    reportType UISReportType,
    startTime, endTime time.Time,
) (*VMMetricsResult, error) {
    
    config := uisReportTypes[reportType]
    
    // 构建请求
    req := &UISReportRequest{
        VMID:      vmID,
        ReportType: config.Type,
        StartTime: startTime.Unix(),
        EndTime:   endTime.Unix(),
    }
    
    // 调用API
    resp, err := uis.callReportAPI(config.URL, req)
    if err != nil {
        return nil, err
    }
    
    // 解析为标准格式（百分比）
    return parseUISMetrics(resp, vmID, reportType), nil
}

// 解析为标准格式（百分比）
func parseUISMetrics(
    raw *UISReportResponse,
    vmID int,
    reportType UISReportType,
) *VMMetricsResult {
    
    metrics := &VMMetricsResult{
        SourcePlatform: "uis",
        DataPoints: []MetricDataPoint{},
    }
    
    for _, item := range raw.Data {
        // UIS 返回小时级数据，每个数据点包含 min/avg/max
        dataPoint := MetricDataPoint{
            Timestamp: time.Unix(item.Timestamp, 0),
            MetricType: mapUISReportType(reportType),
            Percentage: item.AvgValue, // 直接使用平均百分比
            SourcePlatform: "uis",
            
            // 额外信息
            MinValue: item.MinValue,
            MaxValue: item.MaxValue,
        }
        metrics.DataPoints = append(metrics.DataPoints, dataPoint)
    }
    
    return metrics
}
```

## 3. ETL 标准化层详细设计

### 3.1 数据标准化处理器

```go
package etl

// StandardizeProcessor 数据标准化处理器
type StandardizeProcessor struct {
    vmConfig *storage.VM // VM配置信息（用于百分比转换）
}

// StandardizeMetric 标准化单个指标数据点
func (p *StandardizeProcessor) StandardizeMetric(
    raw *MetricDataPoint,
) (*StandardizedMetric, error) {
    
    standardized := &StandardizedMetric{
        Timestamp:      raw.Timestamp,
        MetricType:     raw.MetricType,
        SourcePlatform: raw.SourcePlatform,
    }
    
    switch raw.SourcePlatform {
    case "vcenter":
        // vCenter: 已知绝对值，计算百分比
        standardized.AbsoluteValue = p.convertVCenterAbsolute(raw)
        standardized.Percentage = p.calculatePercentage(
            standardized.AbsoluteValue,
            raw.MetricType,
            p.vmConfig,
        )
        
    case "uis":
        // UIS: 已知百分比，计算绝对值
        standardized.Percentage = raw.Percentage
        standardized.AbsoluteValue = p.calculateAbsolute(
            raw.Percentage,
            raw.MetricType,
            p.vmConfig,
        )
    }
    
    // 数据质量评分
    standardized.QualityScore = p.assessDataQuality(raw, standardized)
    
    return standardized, nil
}

// convertVCenterAbsolute 转换 vCenter 绝对值单位
func (p *StandardizeProcessor) convertVCenterAbsolute(raw *MetricDataPoint) float64 {
    switch raw.MetricType {
    case "cpu":
        // CPU: MHz → Cores
        // AbsoluteValue(MHz) / CpuMhz(单核频率) = 使用的核心数
        cpuMhz := float64(p.vmConfig.CpuMhz) // 从Host配置获取
        if cpuMhz == 0 {
            cpuMhz = 2000 // 默认2GHz
        }
        return raw.AbsoluteValue / cpuMhz
        
    case "memory":
        // Memory: Bytes → MB
        return raw.AbsoluteValue / (1024 * 1024)
        
    case "disk":
        // Disk: 保持 IOPS
        return raw.AbsoluteValue
        
    case "network":
        // Network: 保持 KB/s
        return raw.AbsoluteValue
        
    default:
        return raw.AbsoluteValue
    }
}

// calculatePercentage 根据绝对值计算百分比
func (p *StandardizeProcessor) calculatePercentage(
    absoluteValue float64,
    metricType string,
    vmConfig *storage.VM,
) float64 {
    
    switch metricType {
    case "cpu":
        // CPU百分比 = (使用Cores / 配置Cores) × 100
        if vmConfig.CpuCount == 0 {
            return 0
        }
        return (absoluteValue / float64(vmConfig.CpuCount)) * 100
        
    case "memory":
        // 内存百分比 = (使用MB / 配置MB) × 100
        if vmConfig.MemoryMB == 0 {
            return 0
        }
        return (absoluteValue / float64(vmConfig.MemoryMB)) * 100
        
    case "disk":
        // 磁盘：如果有IOPS上限，可以计算百分比
        // 否则返回绝对值（IOPS）
        if vmConfig.DiskIOPSLimit > 0 {
            return (absoluteValue / float64(vmConfig.DiskIOPSLimit)) * 100
        }
        return absoluteValue // 无法转换为百分比，保持绝对值
        
    case "network":
        // 网络：如果有带宽上限，可以计算百分比
        if vmConfig.NetworkLimitKB > 0 {
            return (absoluteValue / float64(vmConfig.NetworkLimitKB)) * 100
        }
        return absoluteValue // 无法转换为百分比，保持绝对值
        
    default:
        return 0
    }
}

// calculateAbsolute 根据百分比计算绝对值
func (p *StandardizeProcessor) calculateAbsolute(
    percentage float64,
    metricType string,
    vmConfig *storage.VM,
) float64 {
    
    switch metricType {
    case "cpu":
        // 绝对CPU使用 = (百分比 / 100) × 配置Cores
        return (percentage / 100) * float64(vmConfig.CpuCount)
        
    case "memory":
        // 绝对内存使用 = (百分比 / 100) × 配置MB
        return (percentage / 100) * float64(vmConfig.MemoryMB)
        
    case "disk":
        // 磁盘：如果百分比是基于IOPS上限
        if vmConfig.DiskIOPSLimit > 0 {
            return (percentage / 100) * float64(vmConfig.DiskIOPSLimit)
        }
        return percentage // 假设直接是IOPS值
        
    case "network":
        // 网络：如果有带宽上限
        if vmConfig.NetworkLimitKB > 0 {
            return (percentage / 100) * float64(vmConfig.NetworkLimitKB)
        }
        return percentage // 假设直接是KB/s值
        
    default:
        return 0
    }
}

// assessDataQuality 评估数据质量
func (p *StandardizeProcessor) assessDataQuality(
    raw *MetricDataPoint,
    standardized *StandardizedMetric,
) float64 {
    
    score := 100.0
    
    // 检查数据合理性
    if standardized.AbsoluteValue < 0 {
        score -= 50 // 负值异常
    }
    
    if standardized.Percentage < 0 || standardized.Percentage > 200 {
        score -= 30 // 百分比超出合理范围（允许200%超配）
    }
    
    // CPU 特殊检查
    if raw.MetricType == "cpu" {
        if standardized.AbsoluteValue > float64(p.vmConfig.CpuCount) * 1.5 {
            score -= 20 // CPU使用超过配置的150%，可能异常
        }
    }
    
    // 内存特殊检查
    if raw.MetricType == "memory" {
        if standardized.Percentage > 100 {
            score -= 10 // 内存使用超过100%异常（但可能balloon）
        }
    }
    
    return math.Max(0, score)
}
```

### 3.2 时间聚合处理器

```go
// AggregateProcessor 时间聚合处理器
type AggregateProcessor struct {
    granularity string // "minute", "hour", "day"
}

// Aggregate 聚合指标数据
func (p *AggregateProcessor) Aggregate(
    metrics []StandardizedMetric,
    timeWindow time.Duration,
) ([]AggregatedMetric, error) {
    
    // 根据时间窗口决定聚合粒度
    granularity := p.determineGranularity(timeWindow)
    
    // 按时间段分组
    groups := p.groupByTimeWindow(metrics, granularity)
    
    // 计算每组的统计值
    var result []AggregatedMetric
    for timestamp, group := range groups {
        agg := p.calculateStatistics(group, timestamp, granularity)
        result = append(result, agg)
    }
    
    return result, nil
}

// determineGranularity 根据时间窗口确定合适的聚合粒度
func (p *AggregateProcessor) determineGranularity(window time.Duration) string {
    if window <= 7*24*time.Hour {
        return "minute" // 7天内：保持分钟级
    } else if window <= 90*24*time.Hour {
        return "hour" // 90天内：聚合为小时级
    } else {
        return "day" // 更长时间：聚合为天级
    }
}

// groupByTimeWindow 按时间窗口分组
func (p *AggregateProcessor) groupByTimeWindow(
    metrics []StandardizedMetric,
    granularity string,
) map[time.Time][]StandardizedMetric {
    
    groups := make(map[time.Time][]StandardizedMetric)
    
    for _, m := range metrics {
        var windowStart time.Time
        
        switch granularity {
        case "minute":
            // 按分钟对齐
            windowStart = m.Timestamp.Truncate(time.Minute)
        case "hour":
            // 按小时对齐
            windowStart = m.Timestamp.Truncate(time.Hour)
        case "day":
            // 按天对齐
            year, month, day := m.Timestamp.Date()
            windowStart = time.Date(year, month, day, 0, 0, 0, 0, m.Timestamp.Location())
        }
        
        groups[windowStart] = append(groups[windowStart], m)
    }
    
    return groups
}

// calculateStatistics 计算统计值
func (p *AggregateProcessor) calculateStatistics(
    metrics []StandardizedMetric,
    timestamp time.Time,
    granularity string,
) AggregatedMetric {
    
    if len(metrics) == 0 {
        return AggregatedMetric{}
    }
    
    // 提取绝对值和百分比
    absValues := make([]float64, len(metrics))
    pctValues := make([]float64, len(metrics))
    qualityScores := make([]float64, len(metrics))
    
    for i, m := range metrics {
        absValues[i] = m.AbsoluteValue
        pctValues[i] = m.Percentage
        qualityScores[i] = m.QualityScore
    }
    
    return AggregatedMetric{
        Timestamp:   timestamp,
        MetricType:  metrics[0].MetricType,
        Granularity: granularity,
        SampleCount: len(metrics),
        
        // 绝对值统计
        AbsoluteMin:    min(absValues),
        AbsoluteMax:    max(absValues),
        AbsoluteAvg:    avg(absValues),
        AbsoluteP50:    percentile(absValues, 50),
        AbsoluteP95:    percentile(absValues, 95),
        
        // 百分比统计
        PercentageMin:  min(pctValues),
        PercentageMax:  max(pctValues),
        PercentageAvg:  avg(pctValues),
        PercentageP50:  percentile(pctValues, 50),
        PercentageP95:  percentile(pctValues, 95),
        
        // 质量评分
        AvgQualityScore: avg(qualityScores),
    }
}
```

## 4. 数据模型优化

### 4.1 优化后的 Metric 表结构

```sql
-- 性能指标表（双格式存储 + 聚合数据）
CREATE TABLE metrics (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    
    -- 关联信息
    vm_id INTEGER NOT NULL,
    metric_type TEXT NOT NULL,  -- 'cpu', 'memory', 'disk_read', 'disk_write', 'net_rx', 'net_tx'
    
    -- 时间信息
    timestamp INTEGER NOT NULL,  -- Unix timestamp
    granularity TEXT NOT NULL,   -- 'minute', 'hour', 'day'
    
    -- 双格式数据（原始值或聚合后的平均值）
    absolute_value REAL,         -- 绝对值 (Cores/MB/IOPS/KB/s)
    percentage REAL,             -- 百分比 (%)
    
    -- 聚合统计（当 granularity != 'minute' 时有效）
    absolute_min REAL,           -- 最小绝对值
    absolute_max REAL,           -- 最大绝对值
    absolute_p95 REAL,           -- P95 绝对值
    percentage_min REAL,         -- 最小百分比
    percentage_max REAL,         -- 最大百分比
    percentage_p95 REAL,         -- P95 百分比
    sample_count INTEGER,        -- 样本数量
    
    -- 元数据
    source_platform TEXT NOT NULL,  -- 'vcenter', 'uis'
    quality_score REAL DEFAULT 100, -- 数据质量分数 (0-100)
    
    -- 时间戳
    created_at INTEGER NOT NULL,
    
    -- 索引
    FOREIGN KEY (vm_id) REFERENCES vms(id) ON DELETE CASCADE
);

CREATE INDEX idx_metrics_vm_type_time ON metrics(vm_id, metric_type, timestamp);
CREATE INDEX idx_metrics_vm_type_granularity ON metrics(vm_id, metric_type, granularity, timestamp);
CREATE INDEX idx_metrics_quality ON metrics(quality_score);
```

### 4.2 VM 配置表扩展

```sql
-- 虚拟机表（添加转换所需的配置信息）
ALTER TABLE vms ADD COLUMN cpu_mhz INTEGER;          -- 单核CPU频率 (MHz)
ALTER TABLE vms ADD COLUMN disk_iops_limit INTEGER;  -- 磁盘IOPS上限（可选）
ALTER TABLE vms ADD COLUMN network_limit_kb INTEGER; -- 网络带宽上限 (KB/s)（可选）
```

## 5. 数据查询接口设计

### 5.1 灵活查询接口

```go
// MetricQuery 指标查询参数
type MetricQuery struct {
    VMID        uint
    MetricTypes []string  // ["cpu", "memory"]
    StartTime   time.Time
    EndTime     time.Time
    
    // 数据格式选择
    PreferFormat string   // "absolute", "percentage", "both"
    
    // 粒度控制
    Granularity  string   // "auto", "minute", "hour", "day"
    
    // 聚合方式
    Aggregation  string   // "avg", "min", "max", "p95", "raw"
}

// MetricRepository 指标仓储
type MetricRepository interface {
    // QueryMetrics 查询指标（智能选择格式和粒度）
    QueryMetrics(query *MetricQuery) ([]Metric, error)
    
    // QueryAbsolute 查询绝对值
    QueryAbsolute(vmID uint, metricType string, start, end time.Time) ([]float64, error)
    
    // QueryPercentage 查询百分比
    QueryPercentage(vmID uint, metricType string, start, end time.Time) ([]float64, error)
    
    // QueryAggregated 查询聚合统计
    QueryAggregated(query *MetricQuery) (*AggregatedStats, error)
}
```

## 6. 数据流验证检查点

### 6.1 关键验证点

| 阶段 | 验证项 | 异常处理 |
|------|--------|----------|
| 采集 | 数据完整性、时间范围、格式正确性 | 记录错误日志、标记低质量数据 |
| 转换 | 单位转换准确性、百分比计算正确性 | 跳过异常数据、记录警告 |
| 存储 | 数据唯一性、索引完整性、关联正确性 | 事务回滚、重试机制 |
| 查询 | 数据范围正确、聚合准确性、性能 | 缓存策略、分页查询 |

### 6.2 数据质量监控

```go
// DataQualityReport 数据质量报告
type DataQualityReport struct {
    TimeRange    TimeRange
    TotalSamples int
    
    QualityDistribution map[string]int // 质量分数分布
    ValidSamples        int             // 有效样本数
    InvalidSamples      int             // 无效样本数
    MissingSamples      int             // 缺失样本数
    
    ByMetricType map[string]*MetricQualityStats
    ByPlatform   map[string]*PlatformQualityStats
}
```

---

## 7. 总结

### 7.1 数据流特点

| 特点 | 说明 |
|------|------|
| **多源统一** | 统一处理 vCenter 和 UIS 的不同数据格式 |
| **双格式存储** | 同时保存绝对值和百分比，满足不同分析需求 |
| **智能粒度** | 根据时间窗口自动选择合适的数据粒度 |
| **质量追踪** | 记录数据质量分数，支持异常数据识别 |
| **灵活查询** | 算法层可按需选择绝对值或百分比进行分析 |

### 7.2 关键优势

1. **解耦采集与分析**：标准化层确保分析层不需要关心数据来源
2. **性能优化**：预聚合数据减少实时计算压力
3. **可扩展性**：新增平台只需实现 Connector 接口 + 添加标准化规则
4. **可追溯性**：保留数据来源和质量信息，支持问题排查

