# JustFit v0.0.2 项目分析报告

## 文档信息

| 项目 | 内容 |
|------|------|
| 文档名称 | 项目分析报告 |
| 版本 | v0.0.2 |
| 日期 | 2026-02-24 |
| 分析范围 | 架构、数据、接口、日志、测试 |

---

## 1. 执行摘要

通过深入分析代码，JustFit 项目存在以下核心问题：

1. **数据模型混乱**：前后端存在多套类型定义，字段命名不一致
2. **数据流断裂**：从采集到展示经过 4-6 次转换，类型安全无法保证
3. **数据库设计缺陷**：缺少任务关联视图，数据独立性差
4. **日志系统缺失**：无结构化日志，无日志级别管理
5. **测试覆盖不足**：缺少单元测试、集成测试

---

## 2. 详细问题分析

### 2.1 数据模型问题

#### 问题 2.1.1：多套类型定义共存

**位置**：
- `internal/storage/models.go` - 数据库模型
- `app.go` - API 响应类型
- `frontend/src/types/api.ts` - 前端 API 类型
- `frontend/src/types/common.ts` - 前端通用类型

**问题描述**：
同一实体在不同文件中有不同的定义，例如 `Connection`：

```go
// storage/models.go
type Connection struct {
    gorm.Model
    Name     string     `json:"name"`
    Platform string     `json:"platform"`
    Host     string     `json:"host"`
    Port     int        `json:"port"`
    Username string     `json:"username"`
    Status   string     `json:"status"`
    LastSync *time.Time `json:"last_sync"`
}

// app.go
type ConnectionInfo struct {
    ID       uint   `json:"id"`
    Name     string `json:"name"`
    Platform string `json:"platform"`
    Host     string `json:"host"`
    Port     int    `json:"port"`
    Username string `json:"username"`
    Status   string `json:"status"`
    LastSync string `json:"last_sync"`  // 类型不同！
}
```

```typescript
// frontend/src/types/api.ts
export interface Connection {
  ID: number;           // PascalCase
  Name: string;
  Platform: PlatformType;
  Host: string;
  Port: number;
  Username: string;
  Status: ConnectionStatus;
  LastSync?: string;
}

// frontend/src/types/common.ts
export interface ConnectionInfo {
  id: number;           // camelCase!
  name: string;
  platform: string;
  host: string;
  port: number;
  username: string;
  status: string;
  last_sync: string;    // snake_case!
}
```

**影响**：
- 字段命名风格不一致（PascalCase vs camelCase vs snake_case）
- 类型转换分散在各处，容易出错
- 修改一个字段需要同步修改多处

#### 问题 2.1.2：手动转换代码重复

**位置**：`app.go` 中的 `ListClusters`, `ListHosts`, `ListVMs` 等方法

```go
// 每个方法都有类似的手动转换代码
func (a *App) ListVMs(connectionID uint) ([]VMListItem, error) {
    vms, err := a.repos.VM.ListByConnectionID(connectionID)
    if err != nil {
        return nil, fmt.Errorf("获取虚拟机列表失败: %w", err)
    }

    result := make([]VMListItem, len(vms))
    for i, v := range vms {
        result[i] = VMListItem{
            ID:            v.ID,
            Name:          v.Name,
            Datacenter:    v.Datacenter,
            UUID:          v.UUID,
            CPUCount:      v.CpuCount,
            MemoryGB:      float64(v.MemoryMB) / 1024,  // 手动转换
            PowerState:    v.PowerState,
            IPAddress:     v.IPAddress,
            GuestOS:       v.GuestOS,
            HostName:      v.HostName,
            OverallStatus: v.OverallStatus,
            CollectedAt:   v.CollectedAt.Format("2006-01-02 15:04:05"),
        }
    }
    return result, nil
}
```

**问题**：
- 内存单位手动转换（MemoryMB → MemoryGB）
- 时间格式手动转换
- 代码重复，维护成本高

### 2.2 数据流问题

#### 问题 2.2.1：采集数据流转换过多

**当前流程**：
```
connector.VMInfo
    ↓ [ETL 转换]
storage.VM
    ↓ [API 转换]
VMListItem
    ↓ [Wails 序列化]
前端 VMListItem
```

**问题**：
- 每个转换点都可能引入错误
- 没有统一的转换逻辑
- 字段验证分散

#### 问题 2.2.2：分析结果数据流复杂

**当前流程**：
```
analyzer.ZombieVMResult
    ↓ [map[string]interface{}]
JSON 字符串
    ↓ [存储]
TaskAnalysisResult.Data
    ↓ [查询]
JSON 字符串
    ↓ [反序列化]
interface{}
    ↓ [类型断言]
ZombieVMResult
```

**问题**：
- 使用 `interface{}` 丢失类型安全
- JSON 序列化/反序列化性能开销
- 错误处理复杂

### 2.3 数据库设计问题

#### 问题 2.3.1：缺少任务关联视图

**问题描述**：
- `TaskVMSnapshot` 存储任务快照
- `VM` 表存储当前 VM 状态
- 两者没有直接关联，无法追溯 VM 历史变化

#### 问题 2.3.2：数据独立性差

**问题描述**：
- 采集数据直接写入主表 (`vms`, `hosts`, `clusters`)
- 多次采集会覆盖之前的数据
- 无法支持历史数据对比

**建议设计**：
```sql
-- 采集快照表（按时间维度）
CREATE TABLE collection_snapshots (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    task_id INTEGER NOT NULL,
    connection_id INTEGER NOT NULL,
    snapshot_time DATETIME NOT NULL,
    status TEXT NOT NULL,
    created_at DATETIME NOT NULL
);

-- VM 快照数据（关联快照表）
CREATE TABLE vm_snapshots (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    snapshot_id INTEGER NOT NULL,
    vm_key TEXT NOT NULL,
    name TEXT NOT NULL,
    cpu_count INTEGER,
    memory_mb INTEGER,
    -- ... 其他字段
    FOREIGN KEY (snapshot_id) REFERENCES collection_snapshots(id)
);
```

### 2.4 前后端接口对接问题

#### 问题 2.4.1：字段命名不匹配

| 后端 JSON Tag | 前端 api.ts | 前端 common.ts |
|--------------|-------------|---------------|
| `cpu_count` | `CPUCount` | `cpu_count` |
| `memory_mb` | `MemoryMB` | `memory_mb` |
| `connection_id` | `ConnectionID` | `connection_id` |
| `last_sync` | `LastSync` | `last_sync` |

#### 问题 2.4.2：类型不匹配

| 后端类型 | 前端类型 | 问题 |
|---------|---------|------|
| `uint` | `number` | 范围不同 |
| `int32` | `number` | 范围不同 |
| `time.Time` | `string` | 格式依赖 |
| `*time.Time` | `string \| undefined` | 空值处理 |

### 2.5 日志系统缺失

**现状**：
- 后端使用 `fmt.Printf` 输出到终端
- 没有日志级别管理
- 没有日志持久化
- 没有结构化日志
- 前端使用 `console.log`，无统一管理

**影响**：
- 生产环境无法排查问题
- 无法追踪用户操作
- 无法分析性能瓶颈

### 2.6 测试覆盖不足

**现状**：
- `test/` 目录下有部分测试文件
- 测试未覆盖核心业务逻辑
- 没有集成测试
- 没有 E2E 测试

---

## 3. 架构优化建议

### 3.1 统一数据模型层

**方案**：引入 DTO (Data Transfer Object) 层

```
┌─────────────────────────────────────────────────────────┐
│                    应用层 (app.go)                      │
│                     ↓ 使用 DTO                          │
├─────────────────────────────────────────────────────────┤
│                  DTO 层 (internal/dto)                   │
│         - 统一的 API 请求/响应结构                      │
│         - 字段验证                                      │
│         - 格式转换                                      │
├─────────────────────────────────────────────────────────┤
│              领域模型层 (internal/domain)                │
│         - 业务逻辑模型                                   │
│         - 与数据库无关                                   │
├─────────────────────────────────────────────────────────┤
│              数据模型层 (internal/storage)               │
│         - 数据库表结构                                   │
│         - GORM 模型                                      │
└─────────────────────────────────────────────────────────┘
```

### 3.2 统一命名规范

**约定**：
1. 后端 JSON Tag 统一使用 `snake_case`
2. 前端 TypeScript 统一使用 `camelCase`
3. 后端结构体字段使用 `PascalCase`

**转换规则**：
```go
// 后端定义
type VMListItem struct {
    ID        uint   `json:"id"`
    CPUCount  int32  `json:"cpu_count"`
    MemoryMB  int32  `json:"memory_mb"`
}

// 前端自动获得（通过类型生成）
export interface VMListItem {
  id: number;
  cpu_count: number;
  memory_mb: number;
}
```

### 3.3 日志系统设计

```go
// internal/logger/logger.go
type Logger struct {
    level      LogLevel
    output     Output
    middleware []Middleware
}

type LogLevel int
const (
    DEBUG LogLevel = iota
    INFO
    WARN
    ERROR
)

type LogEntry struct {
    Timestamp time.Time              `json:"timestamp"`
    Level     string                 `json:"level"`
    Message   string                 `json:"message"`
    Fields    map[string]interface{} `json:"fields,omitempty"`
    Context   map[string]interface{} `json:"context,omitempty"`
}
```

### 3.4 数据库架构优化

```
┌─────────────────────────────────────────────────────────┐
│                    任务中心                             │
│  ┌─────────────────────────────────────────────────────┐│
│  │ tasks 表 - 任务元数据                               ││
│  └─────────────────────────────────────────────────────┘│
│                       ↓                                 │
│  ┌────────────────────────────────────────────────────┐│
│  │ collection_snapshots 表 - 采集快照                 ││
│  │ analysis_snapshots 表 - 分析快照                   ││
│  └─────────────────────────────────────────────────────┘│
│                       ↓                                 │
│  ┌─────────────────────────────────────────────────────┐│
│  │ vm_snapshots 表 - VM 历史快照                      ││
│  │ metric_snapshots 表 - 指标历史快照                 ││
│  └─────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────┘
```

---

## 4. 改进优先级

### P0 - 立即修复（阻塞性问题）
1. 统一前后端数据类型定义
2. 建立日志系统
3. 修复类型不匹配问题

### P1 - 高优先级（影响功能）
1. 重构数据库表结构
2. 实现 DTO 层
3. 添加单元测试

### P2 - 中优先级（改进质量）
1. 实现任务关联视图
2. 添加集成测试
3. 性能优化

### P3 - 低优先级（锦上添花）
1. API 文档生成
2. E2E 测试
3. 监控告警

---

## 5. 下一步行动

详见 《01-操作方案.md》
