# JustFit v0.0.2 操作方案

## 文档信息

| 项目 | 内容 |
|------|------|
| 文档名称 | 操作方案 |
| 版本 | v0.0.2 |
| 日期 | 2026-02-24 |
| 前置文档 | 00-项目分析报告.md |

---

## 1. 总体目标

1. **统一数据模型** - 建立清晰的 DTO 层，统一前后端类型定义
2. **重构数据库** - 引入快照机制，支持历史数据追溯
3. **建立日志系统** - 结构化日志，支持多级别输出
4. **完善测试** - 单元测试、集成测试、接口测试

---

## 2. 操作排序

### 阶段 1：基础设施（2-3天）
1. 创建目录结构
2. 建立日志系统
3. 统一命名规范文档

### 阶段 2：数据模型重构（3-4天）
1. 设计 DTO 层
2. 设计领域模型层
3. 实现 Mapper 转换器
4. 生成前端类型定义

### 阶段 3：数据库重构（2-3天）
1. 设计新的表结构
2. 编写迁移脚本
3. 实现快照机制

### 阶段 4：应用层重构（3-4天）
1. 重写 app.go，使用 DTO
2. 统一错误处理
3. 添加日志记录

### 阶段 5：测试建设（持续）
1. 编写单元测试
2. 编写集成测试
3. 编写接口测试
4. 提供 E2E 测试指导

---

## 3. 目录结构规划

```
justfit/
├── cmd/                        # 命令行工具（可选）
│   └── migrate/                # 数据库迁移工具
│
├── internal/
│   ├── dto/                    # 新增：DTO 层
│   │   ├── request/            # 请求 DTO
│   │   │   ├── connection.go
│   │   │   ├── task.go
│   │   │   ├── analysis.go
│   │   │   └── report.go
│   │   ├── response/           # 响应 DTO
│   │   │   ├── common.go       # 通用响应结构
│   │   │   ├── connection.go
│   │   │   ├── resource.go     # 资源相关 (VM/Host/Cluster)
│   │   │   ├── task.go
│   │   │   └── analysis.go
│   │   └── mapper/             # 新增：数据映射器
│   │       ├── vm_mapper.go
│   │       ├── host_mapper.go
│   │       ├── cluster_mapper.go
│   │       └── task_mapper.go
│   │
│   ├── domain/                 # 新增：领域模型层
│   │   ├── entity/             # 领域实体
│   │   │   ├── connection.go
│   │   │   ├── vm.go
│   │   │   ├── host.go
│   │   │   ├── cluster.go
│   │   │   └── metric.go
│   │   ├── valueobject/        # 值对象
│   │   │   ├── cpu.go
│   │   │   ├── memory.go
│   │   │   └── time_range.go
│   │   └── service/            # 领域服务
│   │       ├── analysis_service.go
│   │       └── collection_service.go
│   │
│   ├── logger/                 # 新增：日志系统
│   │   ├── logger.go           # 核心日志器
│   │   ├── level.go            # 日志级别
│   │   ├── output.go           # 输出适配器
│   │   └── middleware.go       # 日志中间件
│   │
│   ├── storage/                # 现有：数据持久化
│   │   ├── db.go
│   │   ├── models.go          # 重构：只包含数据库表结构
│   │   ├── snapshot/          # 新增：快照相关
│   │   │   ├── task_snapshot.go
│   │   │   ├── vm_snapshot.go
│   │   │   └── metric_snapshot.go
│   │   └── repository/        # 现有：数据仓储
│   │       ├── connection_repo.go
│   │       ├── vm_repo.go
│   │       └── ...
│   │
│   ├── connector/              # 现有：连接器
│   ├── etl/                    # 现有：ETL
│   ├── analyzer/               # 现有：分析器
│   ├── task/                   # 现有：任务调度
│   ├── report/                 # 现有：报告生成
│   ├── security/               # 现有：安全模块
│   ├── service/                # 现有：任务执行器
│   ├── appdir/                 # 现有：目录管理
│   ├── config/                 # 现有：配置管理
│   │
│   ├── errors/                 # 新增：统一错误处理
│   │   ├── errors.go          # 错误定义
│   │   └── handler.go         # 错误处理器
│   │
│   └── app.go                  # 重构：应用入口（使用 DTO）
│
├── frontend/
│   ├── src/
│   │   ├── types/
│   │   │   ├── api.generated.ts # 新增：自动生成的类型
│   │   │   └── models.ts       # 新增：领域模型类型
│   │   ├── api/
│   │   │   ├── client.ts       # 新增：API 客户端封装
│   │   │   └── ...
│   │   ├── logger/            # 新增：前端日志
│   │   │   ├── logger.ts
│   │   │   └── console.ts
│   │   └── ...
│   └── ...
│
├── test/                        # 测试
│   ├── unit/                   # 新增：单元测试
│   │   ├── dto/
│   │   ├── mapper/
│   │   ├── logger/
│   │   └── domain/
│   ├── integration/            # 新增：集成测试
│   │   ├── storage/
│   │   ├── connector/
│   │   └── api/
│   ├── scripts/                # 测试脚本
│   │   ├── test_unit.sh
│   │   ├── test_integration.sh
│   │   └── test_api.sh
│   └── fixtures/               # 测试数据
│       ├── vcenter_response.json
│       └── uis_response.json
│
├── scripts/                     # 新增：脚本工具
│   ├── generate_types.sh       # 生成前端类型
│   └── migrate_db.sh           # 数据库迁移
│
├── docs/                        # 文档
│   └── 0.0.2/
│       ├── 00-项目分析报告.md
│       ├── 01-操作方案.md       # 本文档
│       ├── 02-数据模型设计.md
│       ├── 03-日志系统设计.md
│       ├── 04-测试方案.md
│       └── 05-版本发布说明.md
│
├── main.go
├── go.mod
├── wails.json
└── README.md
```

---

## 4. 详细操作步骤

### 4.1 阶段 1：基础设施

#### 操作 1.1：创建目录结构

```bash
# 创建后端目录
mkdir -p internal/dto/{request,response,mapper}
mkdir -p internal/domain/{entity,valueobject,service}
mkdir -p internal/storage/snapshot
mkdir -p internal/errors
mkdir -p internal/logger

# 创建测试目录
mkdir -p test/{unit,integration,scripts,fixtures}

# 创建前端目录
mkdir -p frontend/src/{api,logger,stores}
mkdir -p frontend/src/types
```

#### 操作 1.2：建立日志系统

详见 `03-日志系统设计.md`

关键文件：
- `internal/logger/logger.go` - 核心日志器
- `internal/logger/output.go` - 输出适配器（文件、控制台、远程）
- `internal/logger/field.go` - 结构化字段

#### 操作 1.3：统一命名规范

创建 `docs/0.0.2/命名规范.md`：

```markdown
# 命名规范

## Go 代码
- 结构体名：PascalCase (例：`VMListItem`)
- 字段名：PascalCase (例：`CPUCount`)
- JSON Tag：snake_case (例：`cpu_count`)
- 方法名：PascalCase (例：`ListVMs`)
- 变量名：camelCase (例：`connectionID`)
- 常量名：PascalCase 或 UPPER_CASE

## TypeScript 代码
- 接口名：PascalCase (例：`VMListItem`)
- 字段名：camelCase (例：`cpuCount`)
- 类名：PascalCase
- 方法名：camelCase
- 常量名：UPPER_SNAKE_CASE

## 数据库
- 表名：snake_case (例：`vm_snapshots`)
- 字段名：snake_case (例：`cpu_count`)
- 索引名：`idx_表名_字段名`
```

### 4.2 阶段 2：数据模型重构

#### 操作 2.1：设计 DTO 层

**请求 DTO 示例** (`internal/dto/request/task.go`):

```go
package request

// CreateTaskRequest 创建任务请求
type CreateTaskRequest struct {
    Type        string   `json:"type" validate:"required,oneof=collection analysis"`
    Name        string   `json:"name" validate:"required,min=1,max=200"`
    ConnectionID uint    `json:"connection_id" validate:"required"`
    SelectedVMs []string `json:"selected_vms"`
}

// ListTasksRequest 查询任务列表请求
type ListTasksRequest struct {
    Status string `json:"status" validate:"omitempty,oneof=pending running completed failed"`
    Limit  int    `json:"limit" validate:"omitempty,min=1,max=100"`
    Offset int    `json:"offset" validate:"omitempty,min=0"`
}
```

**响应 DTO 示例** (`internal/dto/response/task.go`):

```go
package response

import "time"

// TaskResponse 任务响应
type TaskResponse struct {
    ID            uint       `json:"id"`
    Type          string     `json:"type"`
    Name          string     `json:"name"`
    Status        string     `json:"status"`
    Progress      int        `json:"progress"`
    Error         string     `json:"error,omitempty"`
    CreatedAt     time.Time  `json:"created_at"`
    StartedAt     *time.Time `json:"started_at,omitempty"`
    CompletedAt   *time.Time `json:"completed_at,omitempty"`
    ConnectionID  uint       `json:"connection_id,omitempty"`
    ConnectionName string    `json:"connection_name,omitempty"`
}

// TaskListResponse 任务列表响应
type TaskListResponse struct {
    Total int64          `json:"total"`
    Items []TaskResponse `json:"items"`
}
```

**通用响应结构** (`internal/dto/response/common.go`):

```go
package response

// Response 统一 API 响应结构
type Response[T any] struct {
    Success bool        `json:"success"`
    Data    T           `json:"data,omitempty"`
    Message string      `json:"message,omitempty"`
    Error   string      `json:"error,omitempty"`
}

// NewSuccessResponse 创建成功响应
func NewSuccessResponse[T any](data T) *Response[T] {
    return &Response[T]{
        Success: true,
        Data:    data,
    }
}

// NewErrorResponse 创建错误响应
func NewErrorResponse(message string) *Response[any] {
    return &Response[any]{
        Success: false,
        Error:   message,
    }
}

// PagedResponse 分页响应
type PagedResponse[T any] struct {
    Total int64 `json:"total"`
    Page  int   `json:"page"`
    Size  int   `json:"size"`
    Items []T   `json:"items"`
}
```

#### 操作 2.2：设计领域模型层

**领域实体示例** (`internal/domain/entity/vm.go`):

```go
package entity

import "time"

// VM 虚拟机领域实体
// 注意：这个实体不包含数据库相关的字段（如 gorm.Model）
type VM struct {
    ID          uint
    VMKey       string
    Name        string
    Datacenter  string
    CPU         CPU
    Memory      Memory
    PowerState  PowerState
    IPAddress   string
    GuestOS     string
    HostName    string
    CollectedAt time.Time
}

// CPU CPU 值对象
type CPU struct {
    Count int32
    MHz   int32
}

// Memory 内存值对象
type Memory struct {
    MB int32
}

// ToGB 转换为 GB
func (m Memory) ToGB() float64 {
    return float64(m.MB) / 1024
}

// PowerState 电源状态
type PowerState string

const (
    PowerStatePoweredOn  PowerState = "poweredOn"
    PowerStatePoweredOff PowerState = "poweredOff"
    PowerStateSuspended  PowerState = "suspended"
)

// IsRunning 是否正在运行
func (p PowerState) IsRunning() bool {
    return p == PowerStatePoweredOn
}
```

#### 操作 2.3：实现 Mapper 转换器

```go
package mapper

import (
    "justfit/internal/domain/entity"
    "justfit/internal/dto/response"
    "justfit/internal/storage"
)

// VMMapper VM 映射器
type VMMapper struct{}

// NewVMMapper 创建 VM 映射器
func NewVMMapper() *VMMapper {
    return &VMMapper{}
}

// ToDomainEntity 转换为领域实体
func (m *VMMapper) ToDomainEntity(model *storage.VM) *entity.VM {
    if model == nil {
        return nil
    }
    return &entity.VM{
        ID:         model.ID,
        VMKey:      model.VMKey,
        Name:       model.Name,
        Datacenter: model.Datacenter,
        CPU: entity.CPU{
            Count: model.CpuCount,
        },
        Memory: entity.Memory{
            MB: model.MemoryMB,
        },
        PowerState:  entity.PowerState(model.PowerState),
        IPAddress:   model.IPAddress,
        GuestOS:     model.GuestOS,
        HostName:    model.HostName,
        CollectedAt: model.CollectedAt,
    }
}

// ToDTO 转换为响应 DTO
func (m *VMMapper) ToDTO(model *storage.VM) *response.VMResponse {
    if model == nil {
        return nil
    }
    return &response.VMResponse{
        ID:         model.ID,
        Name:       model.Name,
        Datacenter: model.Datacenter,
        CPUCount:   model.CpuCount,
        MemoryGB:   float64(model.MemoryMB) / 1024,
        PowerState: model.PowerState,
        IPAddress:  model.IPAddress,
        GuestOS:    model.GuestOS,
        HostName:   model.HostName,
        CollectedAt: model.CollectedAt,
    }
}

// ToDTOList 批量转换
func (m *VMMapper) ToDTOList(models []storage.VM) []response.VMResponse {
    result := make([]response.VMResponse, len(models))
    for i := range models {
        result[i] = *m.ToDTO(&models[i])
    }
    return result
}
```

#### 操作 2.4：生成前端类型定义

创建脚本 `scripts/generate_types.sh`：

```bash
#!/bin/bash
# 从 Go DTO 生成 TypeScript 类型定义

echo "/**
 * 自动生成的 API 类型定义
 * 不要手动编辑
 * 生成时间: $(date -Iseconds)
 */" > frontend/src/types/api.generated.ts

# 使用 go run 运行生成器
go run scripts/codegen/main.go >> frontend/src/types/api.generated.ts
```

### 4.3 阶段 3：数据库重构

#### 操作 3.1：设计新的表结构

详见 `02-数据模型设计.md`

#### 操作 3.2：编写迁移脚本

```go
// cmd/migrate/main.go
package main

func main() {
    // 1. 备份现有数据库
    // 2. 创建新表
    // 3. 迁移数据
    // 4. 验证数据
}
```

### 4.4 阶段 4：应用层重构

#### 操作 4.1：重写 app.go

```go
package main

import (
    "justfit/internal/dto/request"
    "justfit/internal/dto/response"
    "justfit/internal/logger"
    "justfit/internal/mapper"
)

type App struct {
    ctx         context.Context
    repos       *storage.Repositories
    mappers     *AppMappers
    logger      *logger.Logger
    // ...
}

type AppMappers struct {
    VM      *mapper.VMMapper
    Host    *mapper.HostMapper
    Cluster *mapper.ClusterMapper
    Task    *mapper.TaskMapper
}

// ListVMs 获取虚拟机列表（使用 DTO）
func (a *App) ListVMs(req *request.ListVMsRequest) *response.PagedResponse[response.VMResponse] {
    // 1. 参数验证
    if err := req.Validate(); err != nil {
        a.logger.Warn("参数验证失败", "error", err)
        return response.NewErrorResponse("参数错误")
    }

    // 2. 查询数据
    vms, total, err := a.repos.VM.ListByConnectionIDPaged(
        req.ConnectionID,
        req.Limit,
        req.Offset,
    )
    if err != nil {
        a.logger.Error("查询 VM 列表失败", "error", err)
        return response.NewErrorResponse("查询失败")
    }

    // 3. 转换为 DTO
    items := a.mappers.VM.ToDTOList(vms)

    // 4. 返回响应
    return response.NewSuccessResponse(&response.PagedResponse[response.VMResponse]{
        Total: total,
        Items: items,
    })
}
```

#### 操作 4.2：统一错误处理

```go
// internal/errors/errors.go
package errors

type AppError struct {
    Code    string
    Message string
    Cause   error
}

func (e *AppError) Error() string {
    if e.Cause != nil {
        return e.Message + ": " + e.Cause.Error()
    }
    return e.Message
}

// 预定义错误
var (
    ErrConnectionNotFound = &AppError{Code: "CONN_NOT_FOUND", Message: "连接不存在"}
    ErrInvalidCredentials = &AppError{Code: "INVALID_CREDENTIALS", Message: "凭据无效"}
    ErrTaskNotFound      = &AppError{Code: "TASK_NOT_FOUND", Message: "任务不存在"}
)
```

### 4.5 阶段 5：测试建设

详见 `04-测试方案.md`

---

## 5. 风险评估

| 风险 | 影响 | 缓解措施 |
|------|------|----------|
| 数据库迁移导致数据丢失 | 高 | 迁移前备份，提供回滚脚本 |
| 前后端类型不匹配 | 中 | 自动化测试覆盖所有 API |
| 重构范围过大 | 高 | 分阶段进行，保持向后兼容 |
| 日志性能影响 | 低 | 异步写入，可配置级别 |

---

## 6. 验收标准

### 功能验收
- [ ] 所有 API 使用统一的 DTO 结构
- [ ] 前后端类型定义自动同步
- [ ] 日志系统正常工作，支持多级别
- [ ] 数据库迁移成功，数据无丢失

### 质量验收
- [ ] 单元测试覆盖率 > 60%
- [ ] 所有集成测试通过
- [ ] 无明显的性能回退
- [ ] 代码通过 golangci-lint 检查

---

## 7. 下一步

执行 `02-数据模型设计.md` 中的详细设计
