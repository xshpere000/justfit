# JustFit v0.0.2 测试方案

## 文档信息

| 项目 | 内容 |
|------|------|
| 文档名称 | 测试方案 |
| 版本 | v0.0.2 |
| 日期 | 2026-02-24 |
| 前置文档 | 02-数据模型设计.md |

---

## 1. 测试策略

### 1.1 测试金字塔

```
                    /\
                   /  \
                  / E2E \           5%
                 /------\
                /        \
               / 集成测试  \        15%
              /------------\
             /              \
            /    单元测试     \     80%
           /------------------\
```

- **单元测试** (80%) - 测试独立函数、方法、类
- **集成测试** (15%) - 测试模块间交互
- **E2E测试** (5%) - 端到端业务流程测试

### 1.2 测试覆盖目标

| 模块 | 单元测试覆盖率 | 集成测试 |
|------|---------------|---------|
| dto/mapper | 90% | - |
| domain/entity | 85% | - |
| logger | 80% | - |
| storage/repository | 70% | ✓ |
| connector | 70% | ✓ |
| analyzer | 75% | ✓ |
| task | 60% | ✓ |
| app.go | 50% | ✓ |

---

## 2. 单元测试

### 2.1 目录结构

```
test/unit/
├── dto/
│   └── mapper/
│       ├── vm_mapper_test.go
│       ├── host_mapper_test.go
│       └── task_mapper_test.go
├── domain/
│   ├── entity/
│   │   ├── vm_test.go
│   │   ├── cpu_test.go
│   │   └── memory_test.go
│   └── valueobject/
│       ├── cpu_test.go
│       └── memory_test.go
├── logger/
│   ├── logger_test.go
│   ├── output_test.go
│   └── level_test.go
├── storage/
│   └── snapshot/
│       └── snapshot_test.go
└── utils/
    └── time_test.go
```

### 2.2 Mapper 测试示例

```go
// test/unit/dto/mapper/vm_mapper_test.go

package mapper_test

import (
    "testing"
    "time"

    "justfit/internal/domain/entity"
    "justfit/internal/dto/mapper"
    "justfit/internal/dto/response"
    "justfit/internal/storage"
)

func TestVMMapper_StorageToDTO(t *testing.T) {
    m := mapper.NewVMMapper()

    tests := []struct {
        name     string
        input    *storage.VM
        expected *response.VMResponse
    }{
        {
            name: "正常 VM",
            input: &storage.VM{
                ID:          1,
                VMKey:       "vm-123",
                Name:        "test-vm",
                Datacenter:  "DC1",
                CPUCount:    4,
                CpuMHz:      2000,
                MemoryMB:    8192, // 8GB
                PowerState:  "poweredOn",
                IPAddress:   "192.168.1.100",
                CollectedAt: time.Date(2024, 2, 24, 10, 0, 0, 0, time.UTC),
            },
            expected: &response.VMResponse{
                ID:          1,
                Name:        "test-vm",
                Datacenter:  "DC1",
                CPUCount:    4,
                MemoryMB:    8192,
                MemoryGB:    8.0,
                PowerState:  "poweredOn",
                IPAddress:   "192.168.1.100",
                CollectedAt: time.Date(2024, 2, 24, 10, 0, 0, 0, time.UTC),
            },
        },
        {
            name:     "空值",
            input:    nil,
            expected: nil,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := m.StorageToDTO(tt.input)

            if tt.expected == nil {
                if result != nil {
                    t.Errorf("期望 nil，得到 %+v", result)
                }
                return
            }

            if result.ID != tt.expected.ID {
                t.Errorf("ID 不匹配: 得到 %d，期望 %d", result.ID, tt.expected.ID)
            }
            if result.MemoryGB != tt.expected.MemoryGB {
                t.Errorf("MemoryGB 不匹配: 得到 %f，期望 %f", result.MemoryGB, tt.expected.MemoryGB)
            }
        })
    }
}

func TestVMMapper_StorageToDTOList(t *testing.T) {
    m := mapper.NewVMMapper()

    input := []storage.VM{
        {ID: 1, Name: "vm-1", MemoryMB: 1024},
        {ID: 2, Name: "vm-2", MemoryMB: 2048},
    }

    result := m.StorageToDTOList(input)

    if len(result) != 2 {
        t.Fatalf("期望 2 个结果，得到 %d", len(result))
    }
}

// 基准测试
func BenchmarkVMMapper_StorageToDTO(b *testing.B) {
    m := mapper.NewVMMapper()
    model := &storage.VM{
        ID:         1,
        Name:       "test-vm",
        MemoryMB:   8192,
        CollectedAt: time.Now(),
    }

    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        m.StorageToDTO(model)
    }
}
```

### 2.3 领域模型测试示例

```go
// test/unit/domain/entity/cpu_test.go

package entity_test

import (
    "testing"

    "justfit/internal/domain/entity"
)

func TestCPU_TotalMHz(t *testing.T) {
    tests := []struct {
        name     string
        cpu      entity.CPU
        expected int64
    }{
        {
            name:     "4核 2GHz",
            cpu:      entity.CPU{Count: 4, MHz: 2000},
            expected: 8000,
        },
        {
            name:     "8核 3GHz",
            cpu:      entity.CPU{Count: 8, MHz: 3000},
            expected: 24000,
        },
        {
            name:     "单核 1GHz",
            cpu:      entity.CPU{Count: 1, MHz: 1000},
            expected: 1000,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := tt.cpu.TotalMHz()
            if result != tt.expected {
                t.Errorf("TotalMHz() = %d，期望 %d", result, tt.expected)
            }
        })
    }
}

func TestMemory_ToGB(t *testing.T) {
    tests := []struct {
        name     string
        memory   entity.Memory
        expected float64
    }{
        {"1GB", entity.Memory{MB: 1024}, 1.0},
        {"2GB", entity.Memory{MB: 2048}, 2.0},
        {"8GB", entity.Memory{MB: 8192}, 8.0},
        {"16GB", entity.Memory{MB: 16384}, 16.0},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := tt.memory.ToGB()
            if result != tt.expected {
                t.Errorf("ToGB() = %f，期望 %f", result, tt.expected)
            }
        })
    }
}
```

### 2.4 日志测试示例

```go
// test/unit/logger/logger_test.go

package logger_test

import (
    "testing"

    "justfit/internal/logger"
    "justfit/test/unit/logger/mem"
)

func TestLogger_Levels(t *testing.T) {
    mem := mem.NewMemoryOutput()
    log := logger.New(&logger.Config{
        Level:   logger.INFO,
        Outputs: []logger.Output{mem},
    })

    // DEBUG 级别的日志不应被记录
    log.Debug("debug message")
    if mem.Contains("debug message") {
        t.Error("DEBUG 日志不应被记录")
    }

    // INFO 级别的日志应被记录
    log.Info("info message")
    if !mem.Contains("info message") {
        t.Error("INFO 日志应被记录")
    }
}

func TestLogger_WithFields(t *testing.T) {
    mem := mem.NewMemoryOutput()
    log := logger.New(&logger.Config{
        Outputs: []logger.Output{mem},
    })

    log.Info("test", logger.Int("count", 123), logger.String("status", "ok"))

    entry := mem.Last()
    if entry == nil {
        t.Fatal("没有日志记录")
    }

    if entry.Fields["count"] != 123 {
        t.Errorf("count 字段错误: 得到 %v", entry.Fields["count"])
    }
}

func TestLogger_Sublogger(t *testing.T) {
    mem := mem.NewMemoryOutput()
    log := logger.New(&logger.Config{
        Outputs: []logger.Output{mem},
    })

    // 创建带预设字段的子日志器
    subLog := log.With(
        logger.String("service", "collector"),
        logger.String("version", "1.0"),
    )

    subLog.Info("test message")

    entry := mem.Last()
    if entry.Fields["service"] != "collector" {
        t.Error("预设字段 service 未传递")
    }
}
```

### 2.5 运行单元测试

```bash
#!/bin/bash
# test/scripts/test_unit.sh

set -e

echo "================================"
echo "  JustFit 单元测试"
echo "================================"

# 颜色定义
GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m'

# 运行所有单元测试
echo ""
echo "运行单元测试..."
go test -v -count=1 ./test/unit/... -coverprofile=coverage.out

# 检查覆盖率
echo ""
echo "检查覆盖率..."
go tool cover -func=coverage.out | grep -E "total:|"

# 生成覆盖率报告
echo ""
echo "生成覆盖率报告..."
go tool cover -html=coverage.out -o coverage.html
echo "${GREEN}覆盖率报告已生成: coverage.html${NC}"

# 运行基准测试
echo ""
echo "运行基准测试..."
go test -bench=. -benchmem ./test/unit/...

echo ""
echo "${GREEN}单元测试完成!${NC}"
```

---

## 3. 集成测试

### 3.1 目录结构

```
test/integration/
├── storage/
│   ├── db_test.go           # 数据库初始化测试
│   ├── repository_test.go   # 仓储测试
│   └── snapshot_test.go     # 快照测试
├── connector/
│   ├── vcenter_test.go      # vCenter 连接器测试
│   └── uis_test.go          # UIS 连接器测试
├── etl/
│   └── etl_test.go          # ETL 流程测试
└── api/
    └── app_test.go          # API 测试
```

### 3.2 数据库集成测试

```go
// test/integration/storage/db_test.go

package storage_test

import (
    "os"
    "testing"

    "justfit/internal/storage"
)

var db *storage.DB

func TestMain(m *testing.M) {
    // 设置测试数据库
    os.Setenv("JUSTFIT_DB_PATH", ":memory:")

    // 初始化数据库
    storage.Init(&storage.Config{InMemory: true})
    db = storage.DB

    // 运行测试
    code := m.Run()

    // 清理
    storage.Close()
    os.Exit(code)
}

func TestDB_AutoMigrate(t *testing.T) {
    err := db.AutoMigrate(
        &storage.Connection{},
        &storage.VM{},
        &storage.CollectionSnapshot{},
        &storage.VMSnapshot{},
    )

    if err != nil {
        t.Fatalf("AutoMigrate 失败: %v", err)
    }

    // 检查表是否创建
    tables := []string{
        "connections", "vms",
        "collection_snapshots", "vm_snapshots",
    }

    for _, table := range tables {
        if !db.Migrator().HasTable(table) {
            t.Errorf("表 %s 未创建", table)
        }
    }
}
```

### 3.3 仓储集成测试

```go
// test/integration/storage/repository_test.go

package repository_test

import (
    "testing"
    "time"

    "justfit/internal/storage"
    "justfit/test/integration/storage"
)

func TestVMRepository_Create(t *testing.T) {
    // 使用测试数据库
    db := storage.GetTestDB()
    repo := storage.NewVMRepository(db)

    // 创建测试数据
    vm := &storage.VM{
        VMKey:      "test-vm-001",
        Name:       "Test VM",
        Datacenter: "DC1",
        CPUCount:   4,
        MemoryMB:   8192,
        PowerState: "poweredOn",
    }

    err := repo.Create(vm)
    if err != nil {
        t.Fatalf("创建 VM 失败: %v", err)
    }

    // 验证创建成功
    if vm.ID == 0 {
        t.Error("VM ID 未设置")
    }
}

func TestVMRepository_ListByConnectionID(t *testing.T) {
    db := storage.GetTestDB()
    repo := storage.NewVMRepository(db)

    // 准备测试数据
    connID := uint(1)
    vms := []storage.VM{
        {ConnectionID: connID, Name: "VM1"},
        {ConnectionID: connID, Name: "VM2"},
        {ConnectionID: uint(2), Name: "VM3"}, // 不同连接
    }

    for i := range vms {
        if err := repo.Create(&vms[i]); err != nil {
            t.Fatalf("准备数据失败: %v", err)
        }
    }

    // 查询
    result, err := repo.ListByConnectionID(connID)
    if err != nil {
        t.Fatalf("查询失败: %v", err)
    }

    // 验证
    if len(result) != 2 {
        t.Errorf("期望 2 个 VM，得到 %d", len(result))
    }
}
```

### 3.4 运行集成测试

```bash
#!/bin/bash
# test/scripts/test_integration.sh

set -e

echo "================================"
echo "  JustFit 集成测试"
echo "================================"

# 需要真实数据库
export JUSTFIT_DB_PATH="/tmp/justfit_test.db"

echo ""
echo "初始化测试数据库..."
rm -f "$JUSTFIT_DB_PATH"

echo ""
echo "运行集成测试..."
go test -v -count=1 ./test/integration/...

echo ""
echo "清理测试数据库..."
rm -f "$JUSTFIT_DB_PATH"

echo ""
echo "集成测试完成!"
```

---

## 4. API 接口测试

### 4.1 测试脚本

```go
// test/api/app_test.go

package api_test

import (
    "bytes"
    "encoding/json"
    "net/http"
    "net/http/httptest"
    "testing"

    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"

    "justfit/internal/dto/request"
    "justfit/internal/dto/response"
)

// setupTestApp 创建测试应用
func setupTestApp(t *testing.T) (*App, *httptest.Server) {
    app := NewTestApp() // 需要实现此方法
    server := httptest.NewServer(app.Handler)
    return app, server
}

func TestAPI_CreateConnection(t *testing.T) {
    _, server := setupTestApp(t)
    defer server.Close()

    // 构造请求
    reqBody := request.CreateConnectionRequest{
        Name:     "Test Connection",
        Platform: "vcenter",
        Host:     "192.168.1.100",
        Port:     443,
        Username: "admin",
        Password: "password",
        Insecure: true,
    }

    body, _ := json.Marshal(reqBody)
    req, _ := http.NewRequest("POST", server.URL+"/api/connections", bytes.NewReader(body))
    req.Header.Set("Content-Type", "application/json")

    // 发送请求
    client := &http.Client{}
    resp, err := client.Do(req)
    require.NoError(t, err)
    defer resp.Body.Close()

    // 验证响应
    assert.Equal(t, http.StatusOK, resp.StatusCode)

    var respBody response.Response[response.ConnectionResponse]
    json.NewDecoder(resp.Body).Decode(&respBody)

    assert.True(t, respBody.Success)
    assert.NotZero(t, respBody.Data.ID)
}

func TestAPI_ListVMs(t *testing.T) {
    app, server := setupTestApp(t)
    defer server.Close()

    // 先准备测试数据
    // ...

    // 查询 VM 列表
    req, _ := http.NewRequest("GET", server.URL+"/api/vms?connection_id=1", nil)
    client := &http.Client{}
    resp, err := client.Do(req)
    require.NoError(t, err)
    defer resp.Body.Close()

    assert.Equal(t, http.StatusOK, resp.StatusCode)

    var respBody response.PagedResponse[response.VMResponse]
    json.NewDecoder(resp.Body).Decode(&respBody)

    assert.GreaterOrEqual(t, respBody.Total, int64(0))
}
```

### 4.2 运行 API 测试

```bash
#!/bin/bash
# test/scripts/test_api.sh

echo "================================"
echo "  JustFit API 测试"
echo "================================"

echo ""
echo "启动测试服务器..."
# 启动测试 API 服务器

echo "运行 API 测试..."
go test -v ./test/api/...

echo ""
echo "API 测试完成!"
```

---

## 5. E2E 测试指导

由于当前环境无法直接执行 E2E 测试，这里提供测试脚本和执行指导。

### 5.1 手动测试用例

```markdown
# E2E 测试用例

## 用例 1: 创建连接并采集数据

### 前置条件
- 应用已启动
- 有可访问的 vCenter/H3C UIS 环境

### 步骤
1. 打开应用，进入"连接管理"页面
2. 点击"新建连接"，填写连接信息
3. 点击"测试连接"，验证连接成功
4. 保存连接
5. 进入"数据采集"页面
6. 选择刚创建的连接
7. 选择采集类型: 集群、主机、虚拟机
8. 设置采集天数: 7天
9. 点击"开始采集"
10. 等待采集完成

### 预期结果
- 连接创建成功
- 测试连接显示"连接成功"
- 采集任务创建成功
- 任务进度从 0% 到 100%
- 采集完成后显示统计数据

## 用例 2: 僵尸 VM 分析

### 前置条件
- 已有采集数据

### 步骤
1. 进入"分析结果" → "僵尸 VM"页面
2. 选择要分析的连接
3. 配置分析参数:
   - 分析天数: 30天
   - CPU 阈值: 5%
   - 内存阈值: 10%
4. 点击"开始分析"
5. 等待分析完成

### 预期结果
- 分析任务创建成功
- 显示分析结果列表
- 每个结果包含 VM 名称、置信度、建议

## 用例 3: 导出报告

### 前置条件
- 已有分析结果

### 步骤
1. 进入任务详情页面
2. 点击"导出报告"
3. 选择导出格式: JSON
4. 等待导出完成

### 预期结果
- 显示导出进度
- 导出完成后提供文件路径
- 可以打开/导出文件
```

### 5.2 自动化测试脚本

```bash
#!/bin/bash
# test/scripts/test_e2e.sh

echo "================================"
echo "  JustFit E2E 测试指导"
echo "================================"
echo ""

cat << 'EOF'
请按照以下步骤执行 E2E 测试：

1. 启动应用
   $ wails dev

2. 打开浏览器开发者工具 (F12)

3. 在 Console 中执行以下脚本：
EOF

echo ""
echo '// E2E 测试脚本'
cat << 'SCRIPT'
// 测试 1: 创建连接
async function testCreateConnection() {
  const req = {
    name: 'E2E Test Connection',
    platform: 'vcenter',
    host: '192.168.1.100',
    port: 443,
    username: 'admin',
    password: 'password',
    insecure: true
  };

  const result = await window.api.CreateConnection(req);
  console.assert(result.success, '创建连接失败');
  console.log('连接 ID:', result.data.id);
  return result.data.id;
}

// 测试 2: 采集数据
async function testCollection(connectionId) {
  const req = {
    connection_id: connectionId,
    data_types: ['clusters', 'hosts', 'vms'],
    metrics_days: 7
  };

  const taskId = await window.api.CreateCollectTask(req);
  console.log('任务 ID:', taskId);

  // 轮询任务状态
  while (true) {
    const task = await window.api.GetTask(taskId);
    console.log('任务状态:', task.status, '进度:', task.progress);

    if (task.status === 'completed' || task.status === 'failed') {
      console.assert(task.status === 'completed', '采集任务失败');
      break;
    }

    await new Promise(r => setTimeout(r, 1000));
  }
}

// 执行测试
testCreateConnection().then(id => testCollection(id));
SCRIPT

echo ""
echo "4. 查看控制台输出，验证测试结果"
echo ""
echo "预期结果:"
echo "  ✓ 所有断言通过"
echo "  ✓ 无错误信息"
echo ""
echo "5. 将测试结果反馈给开发人员"
echo ""
echo "================================"
```

---

## 6. 测试数据管理

### 6.1 Mock 数据

```go
// test/fixtures/vcenter_mock.go

package fixtures

// MockVMInfo 模拟 vCenter VM 信息
var MockVMInfo = []connector.VMInfo{
    {
        VMKey:      "vm-1",
        Name:       "test-vm-1",
        UUID:       "501e-xxxx-xxxx",
        CpuCount:   4,
        MemoryMB:   8192,
        PowerState: "poweredOn",
        GuestOS:     "Ubuntu 22.04",
        HostName:   "esxi-1.local",
    },
    // ...
}

// MockVMMetrics 模拟性能指标
var MockVMMetrics = &connector.VMMetrics{
    CPU: []MetricPoint{
        {Timestamp: time.Now().Add(-1 * time.Hour), Value: 20.5},
        {Timestamp: time.Now().Add(-30 * time.Minute), Value: 15.2},
        {Timestamp: time.Now(), Value: 18.8},
    },
    Memory: []MetricPoint{
        {Timestamp: time.Now().Add(-1 * time.Hour), Value: 60.2},
        {Timestamp: time.Now().Add(-30 * time.Minute), Value: 58.1},
        {Timestamp: time.Now(), Value: 62.5},
    },
}
```

### 6.2 测试数据库

```go
// test/fixtures/db.go

package fixtures

import (
    "justfit/internal/storage"
)

// SetupTestDB 设置测试数据库
func SetupTestDB(t *testing.T) *gorm.DB {
    db, err := gorm.Open(sqlite.Open(":memory:"), &gorm.Config{})
    require.NoError(t, err)

    // 自动迁移
    err = db.AutoMigrate(
        &storage.Connection{},
        &storage.VM{},
        &storage.Task{},
        // ...
    )
    require.NoError(t, err)

    return db
}

// SeedTestData 填充测试数据
func SeedTestData(db *gorm.DB) error {
    // 创建测试连接
    conn := &storage.Connection{
        Name:     "Test Connection",
        Platform: "vcenter",
        Host:     "192.168.1.100",
        Port:     443,
        Username: "admin",
        Status:   "connected",
    }
    if err := db.Create(conn).Error; err != nil {
        return err
    }

    // 创建测试 VM
    vms := []storage.VM{
        {
            ConnectionID: conn.ID,
            VMKey:       "vm-1",
            Name:        "Test VM 1",
            CpuCount:    4,
            MemoryMB:    8192,
            PowerState:  "poweredOn",
        },
        {
            ConnectionID: conn.ID,
            VMKey:       "vm-2",
            Name:        "Test VM 2",
            CpuCount:    2,
            MemoryMB:    4096,
            PowerState:  "poweredOn",
        },
    }

    return db.Create(&vms).Error
}
```

---

## 7. 测试执行指南

### 7.1 执行全部测试

```bash
# 一键运行所有测试
make test

# 或
./scripts/test_all.sh
```

### 7.2 执行特定测试

```bash
# 只运行单元测试
go test ./test/unit/...

# 只运行集成测试
go test ./test/integration/...

# 运行特定包的测试
go test ./test/unit/dto/mapper/...

# 运行特定测试函数
go test -run TestVMMapper ./test/unit/dto/mapper/
```

### 7.3 生成覆盖率报告

```bash
# 生成覆盖率
go test -coverprofile=coverage.out ./...
go tool cover -html=coverage.out

# 在浏览器中打开
open coverage.html
```

---

## 8. 持续集成配置

### 8.1 GitHub Actions

```yaml
# .github/workflows/test.yml

name: Test

on:
  push:
    branches: [ main, develop ]
  pull_request:

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.24'

    - name: Install dependencies
      run: go mod download

    - name: Run unit tests
      run: go test -v -race -coverprofile=coverage.out ./test/unit/...

    - name: Run integration tests
      run: go test -v ./test/integration/...

    - name: Upload coverage
      uses: codecov/codecov-action@v3
      with:
        files: ./coverage.out
```

---

## 9. 用户手动测试反馈表

测试完成后，请填写以下信息反馈给开发人员：

```markdown
# 测试反馈表

## 测试环境
- 操作系统: [Linux/Mac/Windows]
- Go 版本: [go version]
- Wails 版本: [wails version]

## 单元测试结果
- [ ] 全部通过
- [ ] 部分失败 (请说明)

## 集成测试结果
- [ ] 全部通过
- [ ] 部分失败 (请说明)

## E2E 测试结果
- [ ] 创建连接测试: [通过/失败]
- [ ] 数据采集测试: [通过/失败]
- [ ] 僵尸 VM 分析: [通过/失败]
- [ ] Right Size 分析: [通过/失败]
- [ ] 导出报告测试: [通过/失败]

## 问题描述
[请详细描述遇到的问题]

## 日志输出
[粘贴相关日志]
```
