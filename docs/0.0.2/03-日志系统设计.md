# JustFit v0.0.2 日志系统设计

## 文档信息

| 项目 | 内容 |
|------|------|
| 文档名称 | 日志系统设计 |
| 版本 | v0.0.2 |
| 日期 | 2026-02-24 |
| 前置文档 | 01-操作方案.md |

---

## 1. 设计目标

1. **结构化日志** - 支持键值对格式，便于检索和分析
2. **多级别输出** - DEBUG, INFO, WARN, ERROR
3. **多输出适配** - 控制台、文件、远程日志服务
4. **性能友好** - 异步写入，低开销
5. **上下文追踪** - 支持链路追踪 ID

---

## 2. 日志级别定义

```go
// internal/logger/level.go

package logger

// Level 日志级别
type Level int

const (
    // DEBUG 调试信息，用于开发排查问题
    DEBUG Level = iota
    // INFO 常规信息，记录正常业务流程
    INFO
    // WARN 警告信息，潜在问题但不影响运行
    WARN
    // ERROR 错误信息，功能异常但程序可继续
    ERROR
)

// String 返回级别字符串
func (l Level) String() string {
    switch l {
    case DEBUG:
        return "DEBUG"
    case INFO:
        return "INFO"
    case WARN:
        return "WARN"
    case ERROR:
        return "ERROR"
    default:
        return "UNKNOWN"
    }
}

// ParseLevel 解析日志级别字符串
func ParseLevel(s string) Level {
    switch s {
    case "DEBUG":
        return DEBUG
    case "INFO":
        return INFO
    case "WARN", "WARNING":
        return WARN
    case "ERROR":
        return ERROR
    default:
        return INFO
    }
}
```

---

## 3. 日志条目设计

```go
// internal/logger/entry.go

package logger

import (
    "context"
    "time"
)

// Entry 日志条目
type Entry struct {
    // 基础字段
    Timestamp time.Time              `json:"timestamp"`
    Level     Level                  `json:"level"`
    Message   string                 `json:"message"`

    // 上下文字段
    Fields    map[string]interface{} `json:"fields,omitempty"`

    // 调用信息
    File      string                 `json:"file,omitempty"`
    Line      int                    `json:"line,omitempty"`
    Function  string                 `json:"function,omitempty"`

    // 追踪信息
    TraceID   string                 `json:"trace_id,omitempty"`
    SpanID    string                 `json:"span_id,omitempty"`

    // 错误信息
    Error     string                 `json:"error,omitempty"`
    Stack     string                 `json:"stack,omitempty"`
}

// Field 键值对字段
type Field struct {
    Key   string
    Value interface{}
}

// F 创建字段快捷方法
func F(key string, value interface{}) Field {
    return Field{Key: key, Value: value}
}

// 常用字段快捷方法
func String(key, value string) Field {
    return Field{Key: key, Value: value}
}

func Int(key string, value int) Field {
    return Field{Key: key, Value: value}
}

func Int64(key string, value int64) Field {
    return Field{Key: key, Value: value}
}

func Float64(key string, value float64) Field {
    return Field{Key: key, Value: value}
}

func Bool(key string, value bool) Field {
    return Field{Key: key, Value: value}
}

func Err(err error) Field {
    return Field{Key: "error", Value: err}
}

func Duration(key string, value time.Duration) Field {
    return Field{Key: key, Value: value.String()}
}

// Any 任意类型字段
func Any(key string, value interface{}) Field {
    return Field{Key: key, Value: value}
}
```

---

## 4. 日志器接口

```go
// internal/logger/logger.go

package logger

import (
    "context"
    "io"
    "time"
)

// Logger 日志器接口
type Logger interface {
    // 基础日志方法
    Debug(msg string, fields ...Field)
    Info(msg string, fields ...Field)
    Warn(msg string, fields ...Field)
    Error(msg string, fields ...Field)

    // 带上下文的日志方法
    DebugCtx(ctx context.Context, msg string, fields ...Field)
    InfoCtx(ctx context.Context, msg string, fields ...Field)
    WarnCtx(ctx context.Context, msg string, fields ...Field)
    ErrorCtx(ctx context.Context, msg string, fields ...Field)

    // 子日志器（带预设字段）
    With(fields ...Field) Logger

    // 设置级别
    SetLevel(level Level)
    GetLevel() Level

    // 添加输出器
    AddOutput(output Output)

    // 同步缓冲区
    Sync() error
}

// Config 日志配置
type Config struct {
    Level      Level     // 日志级别
    Outputs    []Output  // 输出器列表
    Format     Format    // 输出格式
    TimeFormat string    // 时间格式
    CallerSkip int       // 调用栈跳过层数
    Async      bool      // 是否异步写入
    BufferSize int       // 异步缓冲区大小
}

// DefaultConfig 默认配置
func DefaultConfig() *Config {
    return &Config{
        Level:      INFO,
        Format:     FormatJSON,
        TimeFormat: "2006-01-02T15:04:05.000Z07:00",
        CallerSkip: 1,
        Async:      true,
        BufferSize: 1000,
    }
}

// loggerImpl 日志器实现
type loggerImpl struct {
    config  *Config
    outputs []Output
    fields  []Field // 预设字段

    // 异步通道
    entryCh chan *Entry
    doneCh   chan struct{}
}

// New 创建新日志器
func New(config *Config) Logger {
    if config == nil {
        config = DefaultConfig()
    }

    l := &loggerImpl{
        config:  config,
        outputs: config.Outputs,
        entryCh: make(chan *Entry, config.BufferSize),
        doneCh:  make(chan struct{}),
    }

    // 启动异步写入协程
    if config.Async {
        go l.asyncWriter()
    }

    return l
}

// Debug 记录调试日志
func (l *loggerImpl) Debug(msg string, fields ...Field) {
    l.log(DEBUG, msg, fields)
}

// Info 记录信息日志
func (l *loggerImpl) Info(msg string, fields ...Field) {
    l.log(INFO, msg, fields)
}

// Warn 记录警告日志
func (l *loggerImpl) Warn(msg string, fields ...Field) {
    l.log(WARN, msg, fields)
}

// Error 记录错误日志
func (l *loggerImpl) Error(msg string, fields ...Field) {
    l.log(ERROR, msg, fields)
}

// log 内部日志方法
func (l *loggerImpl) log(level Level, msg string, fields []Field) {
    // 级别过滤
    if level < l.config.Level {
        return
    }

    // 获取调用信息
    caller := getCaller(l.config.CallerSkip)

    // 创建日志条目
    entry := &Entry{
        Timestamp: time.Now(),
        Level:     level,
        Message:   msg,
        File:      caller.file,
        Line:      caller.line,
        Function:  caller.function,
    }

    // 合并字段（预设字段 + 本次字段）
    entry.Fields = make(map[string]interface{})
    for _, f := range l.fields {
        entry.Fields[f.Key] = f.Value
    }
    for _, f := range fields {
        if f.Key == "error" && err, ok := f.Value.(error); ok {
            entry.Error = err.Error()
            entry.Stack = getStackTrace(err)
        }
        entry.Fields[f.Key] = f.Value
    }

    // 输出
    if l.config.Async {
        select {
        case l.entryCh <- entry:
        default:
            // 缓冲区满，同步写入
            l.write(entry)
        }
    } else {
        l.write(entry)
    }
}

// write 写入所有输出器
func (l *loggerImpl) write(entry *Entry) {
    for _, output := range l.outputs {
        _ = output.Write(entry)
    }
}

// asyncWriter 异步写入协程
func (l *loggerImpl) asyncWriter() {
    for {
        select {
        case entry := <-l.entryCh:
            l.write(entry)
        case <-l.doneCh:
            // 处理剩余日志
            for len(l.entryCh) > 0 {
                l.write(<-l.entryCh)
            }
            return
        }
    }
}

// With 创建带预设字段的子日志器
func (l *loggerImpl) With(fields ...Field) Logger {
    newFields := make([]Field, len(l.fields)+len(fields))
    copy(newFields, l.fields)
    copy(newFields[len(l.fields):], fields)

    return &loggerImpl{
        config:  l.config,
        outputs: l.outputs,
        fields:  newFields,
        entryCh: l.entryCh,
        doneCh:  l.doneCh,
    }
}

// SetLevel 设置日志级别
func (l *loggerImpl) SetLevel(level Level) {
    l.config.Level = level
}

// GetLevel 获取日志级别
func (l *loggerImpl) GetLevel() Level {
    return l.config.Level
}

// AddOutput 添加输出器
func (l *loggerImpl) AddOutput(output Output) {
    l.outputs = append(l.outputs, output)
}

// Sync 同步缓冲区
func (l *loggerImpl) Sync() error {
    // 通知停止
    close(l.doneCh)
    return nil
}

// getCaller 获取调用者信息
func getCaller(skip int) struct {
    file     string
    line     int
    function string
} {
    // 使用 runtime.Caller 获取调用栈信息
    // ...
    return struct{file, line, function string}{}
}

// getStackTrace 获取错误堆栈
func getStackTrace(err error) string {
    // 使用 runtime/debug.Stack()
    return ""
}
```

---

## 5. 输出适配器

```go
// internal/logger/output.go

package logger

import (
    "fmt"
    "io"
    "os"
    "path/filepath"
    "sync"

    "gopkg.in/natefinch/lumberjack.v2"
)

// Output 输出适配器接口
type Output interface {
    Write(entry *Entry) error
    Sync() error
    Close() error
}

// Format 日志格式
type Format int

const (
    FormatJSON Format = iota
    FormatText
)

// ConsoleOutput 控制台输出
type ConsoleOutput struct {
    mu     sync.Mutex
    writer io.Writer
    format Format
}

// NewConsoleOutput 创建控制台输出
func NewConsoleOutput(format Format) *ConsoleOutput {
    return &ConsoleOutput{
        writer: os.Stdout,
        format: format,
    }
}

// Write 写入日志
func (o *ConsoleOutput) Write(entry *Entry) error {
    o.mu.Lock()
    defer o.mu.Unlock()

    var data []byte
    switch o.format {
    case FormatJSON:
        data = o.formatJSON(entry)
    case FormatText:
        data = o.formatText(entry)
    }

    _, err := o.writer.Write(append(data, '\n'))
    return err
}

func (o *ConsoleOutput) Sync() error {
    if f, ok := o.writer.(interface{ Sync() error }); ok {
        return f.Sync()
    }
    return nil
}

func (o *ConsoleOutput) Close() error {
    return nil
}

func (o *ConsoleOutput) formatJSON(entry *Entry) []byte {
    // JSON 序列化
    // ...
    return []byte("{}")
}

func (o *ConsoleOutput) formatText(entry *Entry) []byte {
    // 文本格式化
    // [2024-02-24 10:00:00] [INFO] [file.go:123] message key=value
    return []byte(fmt.Sprintf("[%s] [%s] %s",
        entry.Timestamp.Format("15:04:05.000"),
        entry.Level,
        entry.Message))
}

// FileOutput 文件输出
type FileOutput struct {
    mu   sync.Mutex
    file io.WriteCloser
}

// NewFileOutput 创建文件输出
func NewFileOutput(filename string) (*FileOutput, error) {
    // 确保目录存在
    dir := filepath.Dir(filename)
    if err := os.MkdirAll(dir, 0755); err != nil {
        return nil, err
    }

    file, err := os.OpenFile(filename, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
    if err != nil {
        return nil, err
    }

    return &FileOutput{file: file}, nil
}

func (o *FileOutput) Write(entry *Entry) error {
    o.mu.Lock()
    defer o.mu.Unlock()

    data := o.formatJSON(entry)
    _, err := o.file.Write(append(data, '\n'))
    return err
}

func (o *FileOutput) Sync() error {
    o.mu.Lock()
    defer o.mu.Unlock()

    if f, ok := o.file.(interface{ Sync() error }); ok {
        return f.Sync()
    }
    return nil
}

func (o *FileOutput) Close() error {
    return o.file.Close()
}

// RotatingFileOutput 日志轮转文件输出
type RotatingFileOutput struct {
    logger *lumberjack.Logger
}

// NewRotatingFileOutput 创建日志轮转输出
func NewRotatingFileOutput(filename string, maxSize, maxBackups, maxAge int) *RotatingFileOutput {
    return &RotatingFileOutput{
        logger: &lumberjack.Logger{
            Filename:   filename,
            MaxSize:    maxSize,    // MB
            MaxBackups: maxBackups, // 保留文件数
            MaxAge:     maxAge,     // 保留天数
            Compress:   true,       // 压缩旧文件
        },
    }
}

func (o *RotatingFileOutput) Write(entry *Entry) error {
    data := o.formatJSON(entry)
    _, err := o.logger.Write(append(data, '\n'))
    return err
}

func (o *RotatingFileOutput) Sync() error {
    return o.logger.Rotate()
}

func (o *RotatingFileOutput) Close() error {
    return nil
}

// MultiOutput 多路输出
type MultiOutput struct {
    outputs []Output
}

// NewMultiOutput 创建多路输出
func NewMultiOutput(outputs ...Output) *MultiOutput {
    return &MultiOutput{outputs: outputs}
}

func (o *MultiOutput) Write(entry *Entry) error {
    var firstErr error
    for _, output := range o.outputs {
        if err := output.Write(entry); err != nil && firstErr == nil {
            firstErr = err
        }
    }
    return firstErr
}

func (o *MultiOutput) Sync() error {
    var firstErr error
    for _, output := range o.outputs {
        if err := output.Sync(); err != nil && firstErr == nil {
            firstErr = err
        }
    }
    return firstErr
}

func (o *MultiOutput) Close() error {
    var firstErr error
    for _, output := range o.outputs {
        if err := output.Close(); err != nil && firstErr == nil {
            firstErr = err
        }
    }
    return firstErr
}
```

---

## 6. 全局日志器

```go
// internal/logger/global.go

package logger

import (
    "os"
    "path/filepath"
)

var (
    // global 全局日志器
    global Logger = New(DefaultConfig())
)

// Init 初始化全局日志器
func Init(config *Config) {
    if config == nil {
        config = DefaultConfig()
    }

    // 默认输出到控制台
    if len(config.Outputs) == 0 {
        config.Outputs = []Output{
            NewConsoleOutput(FormatJSON),
        }
    }

    global = New(config)
}

// InitWithFile 初始化日志器（输出到文件）
func InitWithFile(logDir string, levelStr string) error {
    // 创建日志目录
    if err := os.MkdirAll(logDir, 0755); err != nil {
        return err
    }

    config := &Config{
        Level:      ParseLevel(levelStr),
        Format:     FormatJSON,
        Async:      true,
        BufferSize: 1000,
    }

    // 添加多路输出
    config.Outputs = []Output{
        NewConsoleOutput(FormatText), // 控制台使用文本格式
        NewRotatingFileOutput(
            filepath.Join(logDir, "justfit.log"),
            100,  // 100MB
            7,    // 保留7个文件
            30,   // 保留30天
        ),
    }

    Init(config)
    return nil
}

// 获取全局日志器方法
func Debug(msg string, fields ...Field) {
    global.Debug(msg, fields...)
}

func Info(msg string, fields ...Field) {
    global.Info(msg, fields...)
}

func Warn(msg string, fields ...Field) {
    global.Warn(msg, fields...)
}

func Error(msg string, fields ...Field) {
    global.Error(msg, fields...)
}

func With(fields ...Field) Logger {
    return global.With(fields...)
}

func SetLevel(level Level) {
    global.SetLevel(level)
}
```

---

## 7. 前端日志系统

```typescript
// frontend/src/logger/logger.ts

export enum LogLevel {
  DEBUG = 0,
  INFO = 1,
  WARN = 2,
  ERROR = 3,
}

export interface LogEntry {
  timestamp: string
  level: LogLevel
  message: string
  context?: Record<string, any>;
  stack?: string;
}

export interface LogOutput {
  write(entry: LogEntry): void;
}

// 控制台输出
class ConsoleOutput implements LogOutput {
  write(entry: LogEntry): void {
    const timestamp = new Date(entry.timestamp).toISOString();
    const level = LogLevel[entry.level];
    const prefix = `[${timestamp}] [${level}]`;

    switch (entry.level) {
      case LogLevel.DEBUG:
        console.debug(prefix, entry.message, entry.context || '');
        break;
      case LogLevel.INFO:
        console.info(prefix, entry.message, entry.context || '');
        break;
      case LogLevel.WARN:
        console.warn(prefix, entry.message, entry.context || '');
        break;
      case LogLevel.ERROR:
        console.error(prefix, entry.message, entry.context || '', entry.stack || '');
        break;
    }
  }
}

// 远程输出（发送到后端）
class RemoteOutput implements LogOutput {
  private url: string;
  private buffer: LogEntry[] = [];
  private flushInterval: number = 5000; // 5秒

  constructor(url: string) {
    this.url = url;
    this.startFlushTimer();
  }

  write(entry: LogEntry): void {
    this.buffer.push(entry);
    if (this.buffer.length >= 100) {
      this.flush();
    }
  }

  private flush(): void {
    if (this.buffer.length === 0) return;

    fetch(this.url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ logs: this.buffer }),
    }).catch(err => console.error('Failed to send logs:', err));

    this.buffer = [];
  }

  private startFlushTimer(): void {
    setInterval(() => this.flush(), this.flushInterval);
  }
}

// Logger 类
export class Logger {
  private outputs: LogOutput[] = [];
  private context: Record<string, any> = {};
  private level: LogLevel = LogLevel.INFO;

  constructor() {
    this.outputs.push(new ConsoleOutput());
  }

  setLevel(level: LogLevel): void {
    this.level = level;
  }

  addOutput(output: LogOutput): void {
    this.outputs.push(output);
  }

  withContext(context: Record<string, any>): Logger {
    const logger = new Logger();
    logger.outputs = this.outputs;
    logger.level = this.level;
    logger.context = { ...this.context, ...context };
    return logger;
  }

  private log(level: LogLevel, message: string, context?: Record<string, any>): void {
    if (level < this.level) return;

    const entry: LogEntry = {
      timestamp: new Date().toISOString(),
      level,
      message,
      context: { ...this.context, ...context },
    };

    // 添加堆栈信息到错误日志
    if (level === LogLevel.ERROR) {
      entry.stack = new Error().stack;
    }

    for (const output of this.outputs) {
      output.write(entry);
    }
  }

  debug(message: string, context?: Record<string, any>): void {
    this.log(LogLevel.DEBUG, message, context);
  }

  info(message: string, context?: Record<string, any>): void {
    this.log(LogLevel.INFO, message, context);
  }

  warn(message: string, context?: Record<string, any>): void {
    this.log(LogLevel.WARN, message, context);
  }

  error(message: string, context?: Record<string, any>): void {
    this.log(LogLevel.ERROR, message, context);
  }
}

// 全局日志实例
export const logger = new Logger();

// 便捷方法
export const debug = (message: string, context?: Record<string, any>) =>
  logger.debug(message, context);

export const info = (message: string, context?: Record<string, any>) =>
  logger.info(message, context);

export const warn = (message: string, context?: Record<string, any>) =>
  logger.warn(message, context);

export const logError = (message: string, context?: Record<string, any>) =>
  logger.error(message, context);
```

---

## 8. 使用示例

### 后端使用

```go
// 在 app.go 中使用
import "justfit/internal/logger"

func (a *App) CreateConnection(req request.CreateConnectionRequest) *response.Response[any] {
    // 记录请求
    log.Info("创建连接请求",
        logger.String("name", req.Name),
        logger.String("platform", req.Platform))

    // 业务逻辑...

    // 记录结果
    if err != nil {
        log.Error("创建连接失败",
            logger.Err(err),
            logger.Int("connection_id", int(req.ID)))
        return response.NewErrorResponse("CONN_CREATE_FAILED", err.Error())
    }

    log.Info("连接创建成功", logger.Uint("id", conn.ID))
    return response.NewSuccessResponse(conn)
}

// 在任务执行器中使用
func (e *CollectionExecutor) Execute(ctx context.Context, task *task.Task) (*task.TaskResult, error) {
    taskLog := log.With(
        logger.String("task_id", fmt.Sprint(task.ID)),
        logger.String("task_type", string(task.Type)),
    )

    taskLog.Info("开始执行任务")

    // 执行采集...
    taskLog.Debug("采集集群信息", logger.Int("count", len(clusters)))

    if err != nil {
        taskLog.Error("任务执行失败", logger.Err(err))
        return nil, err
    }

    taskLog.Info("任务执行完成", logger.Int("vm_count", len(vms)))
    return result, nil
}
```

### 前端使用

```typescript
// 在 API 调用中使用
import { logger } from '@/logger';

export async function createConnection(req: CreateConnectionRequest): Promise<ConnectionResponse> {
  logger.info('创建连接', { name: req.name, platform: req.platform });

  try {
    const result = await window.api.CreateConnection(req);
    logger.info('连接创建成功', { id: result.id });
    return result;
  } catch (error) {
    logger.error('创建连接失败', { error, request: req });
    throw error;
  }
}

// 在组件中使用
import { logger } from '@/logger';

export default defineComponent({
  setup() {
    onMounted(() => {
      logger.info('组件挂载', { component: 'ConnectionList' });
    });

    const handleDelete = async (id: number) => {
      logger.debug('删除连接', { id });
      // ...
    };
  }
});
```

---

## 9. 日志文件管理

### 日志目录结构

```
~/.justfit/logs/                    # Linux/Mac
│
├── justfit.log                     # 主日志（当前）
├── justfit-2024-02-23.log          # 按日期轮转
├── justfit-2024-02-22.log.gz       # 压缩归档
│
├── error.log                       # 错误日志（单独）
└── task_123.log                    # 任务日志（按任务ID）
```

### 日志级别配置

```go
// 开发环境
config.Level = logger.DEBUG

// 生产环境
config.Level = logger.INFO
```

### 日志轮转策略

| 配置项 | 说明 | 建议值 |
|-------|------|--------|
| MaxSize | 单个文件最大大小 | 100 MB |
| MaxBackups | 保留的历史文件数量 | 7 个 |
| MaxAge | 保留天数 | 30 天 |
| Compress | 是否压缩旧文件 | true |

---

## 10. 性能考虑

1. **异步写入** - 使用缓冲通道，避免阻塞主流程
2. **批量写入** - 积累一定数量后批量写入文件
3. **级别过滤** - 在日志器入口过滤，避免不必要的处理
4. **字段懒求值** - 只有在日志级别满足时才计算字段值

---

## 11. 测试支持

```go
// test/logger/memory_output.go

package logger

// MemoryOutput 内存输出（用于测试）
type MemoryOutput struct {
    entries []*Entry
    mu      sync.Mutex
}

func NewMemoryOutput() *MemoryOutput {
    return &MemoryOutput{entries: make([]*Entry, 0)}
}

func (o *MemoryOutput) Write(entry *Entry) error {
    o.mu.Lock()
    defer o.mu.Unlock()
    o.entries = append(o.entries, entry)
    return nil
}

func (o *MemoryOutput) Sync() error { return nil }
func (o *MemoryOutput) Close() error { return nil }

// Entries 获取所有日志条目
func (o *MemoryOutput) Entries() []*Entry {
    o.mu.Lock()
    defer o.mu.Unlock()
    return o.entries
}

// Last 获取最后一条日志
func (o *MemoryOutput) Last() *Entry {
    o.mu.Lock()
    defer o.mu.Unlock()
    if len(o.entries) == 0 {
        return nil
    }
    return o.entries[len(o.entries)-1]
}

// Clear 清空日志
func (o *MemoryOutput) Clear() {
    o.mu.Lock()
    defer o.mu.Unlock()
    o.entries = make([]*Entry, 0)
}

// Contains 检查是否包含特定日志
func (o *MemoryOutput) Contains(message string) bool {
    for _, e := range o.Entries() {
        if e.Message == message {
            return true
        }
    }
    return false
}

// 使用示例
func TestLogger(t *testing.T) {
    mem := NewMemoryOutput()
    log := logger.New(&logger.Config{Outputs: []logger.Output{mem}})

    log.Info("test message", logger.Int("count", 123))

    assert.Equal(t, 1, len(mem.Entries()))
    assert.Equal(t, "test message", mem.Last().Message)
}
```
